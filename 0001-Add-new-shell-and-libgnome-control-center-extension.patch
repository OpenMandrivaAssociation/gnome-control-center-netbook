From bf8770fc84696207fad6f60f38123c7b258b4bca Mon Sep 17 00:00:00 2001
From: Thomas Wood <thomas.wood@intel.com>
Date: Fri, 3 Sep 2010 11:43:21 +0100
Subject: [PATCH 01/13] Add new shell and libgnome-control-center-extension

---
 Makefile.am                                        |    6 -
 capplets/accessibility/at-properties/Makefile.am   |    2 +-
 capplets/appearance/Makefile.am                    |    5 +-
 capplets/common/Makefile.am                        |  101 ++-
 capplets/common/activate-settings-daemon.c         |    2 +-
 capplets/common/capplet-stock-icons.c              |    3 +-
 capplets/common/capplet-util.c                     |    2 +-
 capplets/common/capplet-util.h                     |    1 -
 capplets/common/cc-page.c                          |  231 +++++
 capplets/common/cc-page.h                          |   61 ++
 capplets/common/cc-panel.c                         |  318 +++++++
 capplets/common/cc-panel.h                         |   68 ++
 capplets/common/cc-shell.c                         |   49 +
 capplets/common/cc-shell.h                         |   76 ++
 capplets/common/cc-theme-thumbnailer-helper.c      |   67 ++
 capplets/common/cc-theme-thumbnailer-slave.c       |  918 ++++++++++++++++++++
 capplets/common/cc-theme-thumbnailer-slave.h       |   65 ++
 capplets/common/cc-theme-thumbnailer.c             |  643 ++++++++++++++
 capplets/common/cc-theme-thumbnailer.h             |   93 ++
 capplets/common/file-transfer-dialog.c             |    2 +-
 capplets/common/gconf-property-editor.c            |    2 +
 capplets/common/gconf-property-editor.h            |    1 -
 capplets/common/gnome-theme-info.c                 |    2 +-
 ...nome-control-center-extension-uninstalled.pc.in |   12 +
 .../common/libgnome-control-center-extension.pc.in |   12 +
 capplets/common/theme-thumbnail.c                  |   13 +
 capplets/display/Makefile.am                       |    2 +-
 capplets/keyboard/gnome-keyboard-properties.c      |    1 +
 configure.ac                                       |   58 ++-
 po/POTFILES.in                                     |    1 +
 shell/Makefile.am                                  |   76 ++-
 shell/cc-shell-category-view.c                     |  278 ++++++
 shell/cc-shell-category-view.h                     |   76 ++
 shell/cc-shell-item-view.c                         |  194 ++++
 shell/cc-shell-item-view.h                         |   72 ++
 shell/cc-shell-marshal.list                        |    1 +
 shell/cc-shell-model.c                             |  101 +++
 shell/cc-shell-model.h                             |   88 ++
 shell/control-center.c                             |  882 +++++++++++++++----
 shell/control-center.h                             |   82 ++
 shell/gnome-control-center.c                       |  108 +++
 shell/shell-search-renderer.c                      |  299 +++++++
 shell/shell-search-renderer.h                      |   74 ++
 shell/shell.ui                                     |  169 ++++
 44 files changed, 5081 insertions(+), 236 deletions(-)
 create mode 100644 capplets/common/cc-page.c
 create mode 100644 capplets/common/cc-page.h
 create mode 100644 capplets/common/cc-panel.c
 create mode 100644 capplets/common/cc-panel.h
 create mode 100644 capplets/common/cc-shell.c
 create mode 100644 capplets/common/cc-shell.h
 create mode 100644 capplets/common/cc-theme-thumbnailer-helper.c
 create mode 100644 capplets/common/cc-theme-thumbnailer-slave.c
 create mode 100644 capplets/common/cc-theme-thumbnailer-slave.h
 create mode 100644 capplets/common/cc-theme-thumbnailer.c
 create mode 100644 capplets/common/cc-theme-thumbnailer.h
 create mode 100644 capplets/common/libgnome-control-center-extension-uninstalled.pc.in
 create mode 100644 capplets/common/libgnome-control-center-extension.pc.in
 create mode 100644 shell/cc-shell-category-view.c
 create mode 100644 shell/cc-shell-category-view.h
 create mode 100644 shell/cc-shell-item-view.c
 create mode 100644 shell/cc-shell-item-view.h
 create mode 100644 shell/cc-shell-marshal.list
 create mode 100644 shell/cc-shell-model.c
 create mode 100644 shell/cc-shell-model.h
 create mode 100644 shell/control-center.h
 create mode 100644 shell/gnome-control-center.c
 create mode 100644 shell/shell-search-renderer.c
 create mode 100644 shell/shell-search-renderer.h
 create mode 100644 shell/shell.ui

diff --git a/Makefile.am b/Makefile.am
index ae0e6d8..646005e 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,13 +1,7 @@
 SUBDIRS = po libwindow-settings capplets font-viewer help
 DIST_SUBDIRS = po libwindow-settings capplets font-viewer help libslab shell typing-break
 
-if HAVE_LIBSLAB_DEPS
-SUBDIRS += libslab
-endif
-
-if HAVE_LIBSLAB
 SUBDIRS += shell
-endif
 
 if HAVE_TYPING_BREAK
 SUBDIRS += typing-break
diff --git a/capplets/accessibility/at-properties/Makefile.am b/capplets/accessibility/at-properties/Makefile.am
index c74c1a7..84d8025 100644
--- a/capplets/accessibility/at-properties/Makefile.am
+++ b/capplets/accessibility/at-properties/Makefile.am
@@ -1,6 +1,6 @@
 bin_PROGRAMS = gnome-at-properties
 
-gnome_at_properties_LDADD = $(AT_CAPPLET_LIBS) $(GNOMECC_CAPPLETS_LIBS) $(top_builddir)/capplets/common/libcommon.la
+gnome_at_properties_LDADD = $(AT_CAPPLET_LIBS) $(GNOMECC_CAPPLETS_LIBS)
 gnome_at_properties_SOURCES = \
 	main.c
 gnome_at_properties_LDFLAGS = -export-dynamic
diff --git a/capplets/appearance/Makefile.am b/capplets/appearance/Makefile.am
index f894f41..cc42f54 100644
--- a/capplets/appearance/Makefile.am
+++ b/capplets/appearance/Makefile.am
@@ -33,7 +33,6 @@ AM_CFLAGS = -DGNOME_DESKTOP_USE_UNSTABLE_API
 
 gnome_appearance_properties_LDADD = \
 	$(top_builddir)/libwindow-settings/libgnome-window-settings.la \
-	$(top_builddir)/capplets/common/libcommon.la \
 	$(GNOMECC_CAPPLETS_LIBS) \
 	$(FONT_CAPPLET_LIBS) \
 	$(METACITY_LIBS)
@@ -51,7 +50,9 @@ INCLUDES = \
 	-DGNOMECC_DATA_DIR="\"$(pkgdatadir)\"" \
 	-DGNOMECC_GTKBUILDER_DIR="\"$(gtkbuilderdir)\"" \
 	-DGNOMECC_PIXMAP_DIR="\"$(pixmapdir)\"" \
-	-DWALLPAPER_DATADIR="\"$(wallpaperdir)\""
+	-DWALLPAPER_DATADIR="\"$(wallpaperdir)\"" \
+	-I$(top_srcdir)/libgnome-control-center-extension/ \
+	-DGNOME_DESKTOP_USE_UNSTABLE_API
 
 CLEANFILES = $(GNOMECC_CAPPLETS_CLEANFILES)
 
diff --git a/capplets/common/Makefile.am b/capplets/common/Makefile.am
index 70ad44f..a7b653c 100644
--- a/capplets/common/Makefile.am
+++ b/capplets/common/Makefile.am
@@ -1,25 +1,47 @@
-EXTRA_DIST =
+NULL =
 
-INCLUDES = \
+uidir = $(pkgdatadir)/ui
+
+INCLUDES =						\
+	-DEXTENSIONSDIR="\"$(EXTENSIONSDIR)\""			\
 	-DGNOMECC_DATA_DIR="\"$(pkgdatadir)\""				\
 	-DGNOMELOCALEDIR="\"$(datadir)/locale\""			\
+	-DLIBEXECDIR="\"$(libexecdir)\""				\
 	-DGTK_ENGINE_DIR="\"$(GTK_ENGINE_DIR)\"" 			\
-	-DG_LOG_DOMAIN=\"capplet-common\"				\
 	-DINSTALL_PREFIX=\"$(prefix)\"					\
 	-I$(top_srcdir)							\
 	-I$(top_srcdir)/libwindow-settings				\
 	-DPIXMAP_DIR=\""$(datadir)/gnome-control-center/pixmaps"\"	\
+	-DUIDIR="\"$(uidir)\""					\
 	$(CAPPLET_CFLAGS)						\
 	$(DBUS_CFLAGS)							\
 	$(GNOME_DESKTOP_CFLAGS)						\
-	$(METACITY_CFLAGS)						\
+	$(WINDOW_MANAGER_CFLAGS)						\
 	$(GSD_DBUS_CFLAGS)						\
 	$(GIO_CFLAGS)
+	$(EXTENSION_COMMON_CFLAGS)			\
+	$(NULL)
+
+
+
+libexec_PROGRAMS = cc-theme-thumbnailer-helper
+
+cc_theme_thumbnailer_helper_DEPENDENCIES = libgnome-control-center-extension.la
 
+cc_theme_thumbnailer_helper_SOURCES =	\
+	cc-theme-thumbnailer-slave.c	\
+	cc-theme-thumbnailer-slave.h	\
+	cc-theme-thumbnailer-helper.c	\
+	$(NULL)
 
-noinst_LTLIBRARIES = libcommon.la
+cc_theme_thumbnailer_helper_LDADD = 	\
+	$(WINDOW_MANAGER_LIBS)		\
+	$(GNOMECC_CAPPLETS_LIBS)	\
+	$(NULL)
 
-libcommon_la_SOURCES = \
+#noinst_LTLIBRARIES = libcommon.la
+
+libcommon_la_sources = \
 	activate-settings-daemon.c	\
 	activate-settings-daemon.h	\
 	capplet-stock-icons.c		\
@@ -38,26 +60,81 @@ libcommon_la_SOURCES = \
 	gnome-theme-info.h		\
 	gtkrc-utils.c			\
 	gtkrc-utils.h			\
+	cc-theme-thumbnailer.c		\
+	cc-theme-thumbnailer.h		\
 	theme-thumbnail.c		\
 	theme-thumbnail.h		\
 	wm-common.c			\
 	wm-common.h
 
-libcommon_la_LIBADD =							\
+#libcommon_la_LIBADD =							\
+#	$(top_builddir)/libwindow-settings/libgnome-window-settings.la  \
+#	$(DBUS_LIBS)							\
+#	$(GNOME_DESKTOP_LIBS)						\
+#	$(GIO_LIBS)
+
+#libcommon_la_LDFLAGS = -export-dynamic -no-undefined -avoid-version
+
+lib_LTLIBRARIES = libgnome-control-center-extension.la
+
+libgnome_control_center_extension_include_HEADERS =	\
+	cc-page.h					\
+	cc-panel.h					\
+	cc-shell.h					\
+	$(NULL)
+
+libgnome_control_center_extension_la_SOURCES =		\
+	$(libcommon_la_sources)				\
+	cc-page.h					\
+	cc-page.c					\
+	cc-panel.h					\
+	cc-panel.c					\
+	cc-shell.c					\
+	cc-shell.h					\
+	$(NULL)
+
+#        -version-info @GNOME_CONTROL_CENTER_EXTENSION_VERSION_INFO@
+libgnome_control_center_extension_la_LDFLAGS =		\
+        -no-undefined					\
+        $(NULL)
+
+libgnome_control_center_extension_la_LIBADD = 		\
 	$(top_builddir)/libwindow-settings/libgnome-window-settings.la  \
-	$(METACITY_LIBS)						\
-	$(DBUS_LIBS)							\
-	$(GNOME_DESKTOP_LIBS)						\
-	$(GIO_LIBS)
+	$(WINDOW_MANAGER_LIBS)				\
+	$(DBUS_LIBS)					\
+	$(GNOME_DESKTOP_LIBS)				\
+	$(GIO_LIBS)					\
+	$(EXTENSION_COMMON_CFLAGS)			\
+	$(NULL)
+
+libgnome_control_center_extension_la_LIBTOOLFLAGS = --tag=disable-static
+
+libgnome_control_center_extension_includedir = $(includedir)/gnome-control-center-1/libgnome-control-center-extension
+
+
 
 gnome_theme_test_SOURCES = \
 	gnome-theme-test.c
 
 gnome_theme_test_LDADD = 						\
-	libcommon.la							\
 	$(GNOMECC_CAPPLETS_LIBS)
 
+gnome_theme_test_DEPENDENCIES = libgnome-control-center-extension.la
+
 noinst_PROGRAMS = \
 	gnome-theme-test
 
+pkgconfigdir=$(libdir)/pkgconfig
+pkgconfig_DATA=libgnome-control-center-extension.pc
+
+EXTRA_DIST =					\
+        libgnome-control-center-extension.pc.in	\
+        $(NULL)
+
+AM_CPPFLAGS =							\
+	-DGNOMELOCALEDIR="\"$(datadir)/locale\""		\
+	-DEXTENSION_DIR="\"$(libdir)/control-center-1/extensions\""					\
+	-DUIDIR="\"$(uidir)\""					\
+	-DMENUDIR="\"$(menudir)\""
+
 -include $(top_srcdir)/git.mk
diff --git a/capplets/common/activate-settings-daemon.c b/capplets/common/activate-settings-daemon.c
index 1829218..c99aa9b 100644
--- a/capplets/common/activate-settings-daemon.c
+++ b/capplets/common/activate-settings-daemon.c
@@ -4,7 +4,7 @@
 
 #include <gnome-settings-daemon/gnome-settings-client.h>
 #include <gtk/gtk.h>
-#include <glib/gi18n.h>
+#include <glib/gi18n-lib.h>
 
 #include "activate-settings-daemon.h"
 
diff --git a/capplets/common/capplet-stock-icons.c b/capplets/common/capplet-stock-icons.c
index 29b440f..1b81750 100644
--- a/capplets/common/capplet-stock-icons.c
+++ b/capplets/common/capplet-stock-icons.c
@@ -22,9 +22,10 @@
  *	Rajkumar Sivasamy <rajkumar.siva@wipro.com>
  *	Taken bits of code from panel-stock-icons.c, Thanks Mark <mark@skynet.ie>
  */
+#include <config.h>
 
 #include <gtk/gtk.h>
-#include <glib/gi18n.h>
+#include <glib/gi18n-lib.h>
 
 #include "capplet-stock-icons.h"
 
diff --git a/capplets/common/capplet-util.c b/capplets/common/capplet-util.c
index 16e5776..e2fc19f 100644
--- a/capplets/common/capplet-util.c
+++ b/capplets/common/capplet-util.c
@@ -31,7 +31,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
-#include <glib/gi18n.h>
+#include <glib/gi18n-lib.h>
 #include <stdlib.h>
 
 #include "capplet-util.h"
diff --git a/capplets/common/capplet-util.h b/capplets/common/capplet-util.h
index 5726565..a7b3688 100644
--- a/capplets/common/capplet-util.h
+++ b/capplets/common/capplet-util.h
@@ -26,7 +26,6 @@
 
 #include <gio/gio.h>
 #include <gtk/gtk.h>
-#include <glib/gi18n.h>
 #include <gconf/gconf.h>
 #include <gconf/gconf-changeset.h>
 
diff --git a/capplets/common/cc-page.c b/capplets/common/cc-page.c
new file mode 100644
index 0000000..f9f03dc
--- /dev/null
+++ b/capplets/common/cc-page.c
@@ -0,0 +1,231 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <gtk/gtk.h>
+#include <gio/gio.h>
+
+#include "cc-page.h"
+
+#define CC_PAGE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_PAGE, CcPagePrivate))
+
+struct CcPagePrivate
+{
+        char            *id;
+        char            *display_name;
+
+        gboolean         is_active;
+};
+
+enum {
+        PROP_0,
+        PROP_ID,
+        PROP_DISPLAY_NAME,
+};
+
+enum {
+        ACTIVE_CHANGED,
+        LAST_SIGNAL
+};
+
+static guint signals [LAST_SIGNAL] = { 0, };
+
+static void     cc_page_class_init    (CcPageClass *klass);
+static void     cc_page_init          (CcPage      *page);
+static void     cc_page_finalize      (GObject     *object);
+
+G_DEFINE_ABSTRACT_TYPE (CcPage, cc_page, GTK_TYPE_ALIGNMENT)
+
+static void
+_cc_page_set_id (CcPage     *page,
+                 const char *id)
+{
+        g_free (page->priv->id);
+        page->priv->id = g_strdup (id);
+}
+
+static void
+_cc_page_set_display_name (CcPage     *page,
+                           const char *name)
+{
+        g_free (page->priv->display_name);
+        page->priv->display_name = g_strdup (name);
+}
+
+static void
+cc_page_set_property (GObject      *object,
+                      guint         prop_id,
+                      const GValue *value,
+                      GParamSpec   *pspec)
+{
+        CcPage *self;
+
+        self = CC_PAGE (object);
+
+        switch (prop_id) {
+        case PROP_ID:
+                _cc_page_set_id (self, g_value_get_string (value));
+                break;
+        case PROP_DISPLAY_NAME:
+                _cc_page_set_display_name (self, g_value_get_string (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+cc_page_get_property (GObject    *object,
+                      guint       prop_id,
+                      GValue     *value,
+                      GParamSpec *pspec)
+{
+        CcPage *self;
+
+        self = CC_PAGE (object);
+
+        switch (prop_id) {
+        case PROP_ID:
+                g_value_set_string (value, self->priv->id);
+                break;
+        case PROP_DISPLAY_NAME:
+                g_value_set_string (value, self->priv->display_name);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+cc_page_real_active_changed (CcPage  *page,
+                             gboolean is_active)
+{
+        page->priv->is_active = is_active;
+        g_debug ("Page %s is %s",
+                 page->priv->id,
+                 page->priv->is_active ? "active" : "inactive");
+}
+
+void
+cc_page_set_active (CcPage  *page,
+                    gboolean is_active)
+{
+        g_return_if_fail (CC_IS_PAGE (page));
+
+        g_object_ref (page);
+        gtk_widget_queue_resize (GTK_WIDGET (page));
+        if (page->priv->is_active != is_active) {
+                g_signal_emit (page, signals [ACTIVE_CHANGED], 0, is_active);
+        }
+        g_object_unref (page);
+}
+
+gboolean
+cc_page_is_active (CcPage  *page)
+{
+        g_return_val_if_fail (CC_IS_PAGE (page), FALSE);
+        return page->priv->is_active;
+}
+
+static GObject *
+cc_page_constructor (GType                  type,
+                     guint                  n_construct_properties,
+                     GObjectConstructParam *construct_properties)
+{
+        CcPage      *page;
+
+        page = CC_PAGE (G_OBJECT_CLASS (cc_page_parent_class)->constructor (type,
+                                                                            n_construct_properties,
+                                                                            construct_properties));
+
+        return G_OBJECT (page);
+}
+
+static void
+cc_page_class_init (CcPageClass *klass)
+{
+        GObjectClass    *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->get_property = cc_page_get_property;
+        object_class->set_property = cc_page_set_property;
+        object_class->constructor = cc_page_constructor;
+        object_class->finalize = cc_page_finalize;
+
+        klass->active_changed = cc_page_real_active_changed;
+
+        g_type_class_add_private (klass, sizeof (CcPagePrivate));
+
+        signals [ACTIVE_CHANGED]
+                = g_signal_new ("active-changed",
+                                G_TYPE_FROM_CLASS (object_class),
+                                G_SIGNAL_RUN_FIRST,
+                                G_STRUCT_OFFSET (CcPageClass, active_changed),
+                                NULL,
+                                NULL,
+                                g_cclosure_marshal_VOID__BOOLEAN,
+                                G_TYPE_NONE,
+                                1, G_TYPE_BOOLEAN);
+
+        g_object_class_install_property (object_class,
+                                         PROP_ID,
+                                         g_param_spec_string ("id",
+                                                              "id",
+                                                              "id",
+                                                              NULL,
+                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (object_class,
+                                         PROP_DISPLAY_NAME,
+                                         g_param_spec_string ("display-name",
+                                                              "display name",
+                                                              "display name",
+                                                              NULL,
+                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+}
+
+static void
+cc_page_init (CcPage *page)
+{
+
+        page->priv = CC_PAGE_GET_PRIVATE (page);
+}
+
+static void
+cc_page_finalize (GObject *object)
+{
+        CcPage *page;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (CC_IS_PAGE (object));
+
+        page = CC_PAGE (object);
+
+        g_return_if_fail (page->priv != NULL);
+
+        g_free (page->priv->id);
+        g_free (page->priv->display_name);
+
+        G_OBJECT_CLASS (cc_page_parent_class)->finalize (object);
+}
diff --git a/capplets/common/cc-page.h b/capplets/common/cc-page.h
new file mode 100644
index 0000000..36f2968
--- /dev/null
+++ b/capplets/common/cc-page.h
@@ -0,0 +1,61 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#ifndef __CC_PAGE_H
+#define __CC_PAGE_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_PAGE         (cc_page_get_type ())
+#define CC_PAGE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), CC_TYPE_PAGE, CcPage))
+#define CC_PAGE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), CC_TYPE_PAGE, CcPageClass))
+#define CC_IS_PAGE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), CC_TYPE_PAGE))
+#define CC_IS_PAGE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), CC_TYPE_PAGE))
+#define CC_PAGE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), CC_TYPE_PAGE, CcPageClass))
+
+typedef struct CcPagePrivate CcPagePrivate;
+
+typedef struct
+{
+        GtkAlignment   parent;
+        CcPagePrivate *priv;
+} CcPage;
+
+typedef struct
+{
+        GtkAlignmentClass   parent_class;
+
+        void (* active_changed)           (CcPage  *page,
+                                           gboolean is_active);
+} CcPageClass;
+
+GType               cc_page_get_type               (void);
+
+gboolean            cc_page_is_active              (CcPage  *page);
+
+void                cc_page_set_active             (CcPage  *page,
+                                                    gboolean is_active);
+
+G_END_DECLS
+
+#endif /* __CC_PAGE_H */
diff --git a/capplets/common/cc-panel.c b/capplets/common/cc-panel.c
new file mode 100644
index 0000000..b8b7551
--- /dev/null
+++ b/capplets/common/cc-panel.c
@@ -0,0 +1,318 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <gtk/gtk.h>
+#include <gio/gio.h>
+
+#include "cc-panel.h"
+#include "cc-page.h"
+
+#define CC_PANEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_PANEL, CcPanelPrivate))
+
+struct CcPanelPrivate
+{
+        char            *id;
+        char            *display_name;
+        char            *category;
+        char            *current_location;
+
+        gboolean         is_active;
+        CcPage          *current_page;
+        CcShell         *shell;
+};
+
+enum {
+        PROP_0,
+        PROP_ID,
+        PROP_DISPLAY_NAME,
+        PROP_CATEGORY,
+        PROP_CURRENT_LOCATION,
+        PROP_CURRENT_PAGE,
+        PROP_SHELL,
+};
+
+enum {
+        ACTIVE_CHANGED,
+        LAST_SIGNAL
+};
+
+static guint signals [LAST_SIGNAL] = { 0, };
+
+static void     cc_panel_class_init    (CcPanelClass *klass);
+static void     cc_panel_init          (CcPanel      *panel);
+static void     cc_panel_finalize      (GObject       *object);
+
+G_DEFINE_ABSTRACT_TYPE (CcPanel, cc_panel, GTK_TYPE_ALIGNMENT)
+
+static void
+_cc_panel_set_id (CcPanel    *panel,
+                  const char *id)
+{
+        g_free (panel->priv->id);
+        panel->priv->id = g_strdup (id);
+}
+
+static void
+_cc_panel_set_display_name (CcPanel    *panel,
+                            const char *name)
+{
+        g_free (panel->priv->display_name);
+        panel->priv->display_name = g_strdup (name);
+}
+
+static void
+_cc_panel_set_current_page (CcPanel    *panel,
+                            CcPage     *page)
+{
+        CcPage *old;
+
+        if (page == panel->priv->current_page)
+                return;
+
+        old = panel->priv->current_page;
+        panel->priv->current_page = page;
+        if (old != NULL) {
+                cc_page_set_active (old, FALSE);
+        }
+        if (panel->priv->current_page != NULL) {
+                g_object_ref (panel->priv->current_page);
+                cc_page_set_active (panel->priv->current_page,
+                                    panel->priv->is_active);
+        }
+        if (old != NULL) {
+                g_object_unref (old);
+        }
+
+        g_object_notify (G_OBJECT (panel), "current-page");
+}
+
+static void
+_cc_panel_set_shell (CcPanel *panel,
+                     CcShell *shell)
+{
+        CcPanelPrivate *priv = panel->priv;
+
+        priv->shell = shell;
+}
+
+
+static void
+cc_panel_set_property (GObject      *object,
+                       guint         prop_id,
+                       const GValue *value,
+                       GParamSpec   *pspec)
+{
+        CcPanel *self;
+
+        self = CC_PANEL (object);
+
+        switch (prop_id) {
+        case PROP_ID:
+                _cc_panel_set_id (self, g_value_get_string (value));
+                break;
+        case PROP_DISPLAY_NAME:
+                _cc_panel_set_display_name (self, g_value_get_string (value));
+                break;
+        case PROP_CURRENT_PAGE:
+                _cc_panel_set_current_page (self, g_value_get_object (value));
+                break;
+        case PROP_SHELL:
+                _cc_panel_set_shell (self, g_value_get_object (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+cc_panel_get_property (GObject    *object,
+                       guint       prop_id,
+                       GValue     *value,
+                       GParamSpec *pspec)
+{
+        CcPanel *self;
+
+        self = CC_PANEL (object);
+
+        switch (prop_id) {
+        case PROP_ID:
+                g_value_set_string (value, self->priv->id);
+                break;
+        case PROP_DISPLAY_NAME:
+                g_value_set_string (value, self->priv->display_name);
+                break;
+        case PROP_CURRENT_PAGE:
+                g_value_set_object (value, self->priv->current_page);
+                break;
+        case PROP_SHELL:
+                g_value_set_object (value, self->priv->shell);
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+cc_panel_real_active_changed (CcPanel *panel,
+                              gboolean is_active)
+{
+        if (panel->priv->is_active == is_active)
+                return;
+
+        panel->priv->is_active = is_active;
+        if (panel->priv->current_page != NULL) {
+                cc_page_set_active (panel->priv->current_page, is_active);
+        }
+        g_debug ("Panel %s is %s",
+                 panel->priv->id,
+                 panel->priv->is_active ? "active" : "inactive");
+}
+
+void
+cc_panel_set_active (CcPanel *panel,
+                     gboolean is_active)
+{
+        g_return_if_fail (CC_IS_PANEL (panel));
+
+        g_object_ref (panel);
+        gtk_widget_queue_resize (GTK_WIDGET (panel));
+        if (panel->priv->is_active != is_active) {
+                g_signal_emit (panel, signals [ACTIVE_CHANGED], 0, is_active);
+        }
+        g_object_unref (panel);
+}
+
+gboolean
+cc_panel_is_active (CcPanel *panel)
+{
+        g_return_val_if_fail (CC_IS_PANEL (panel), FALSE);
+        return panel->priv->is_active;
+}
+
+static GObject *
+cc_panel_constructor (GType                  type,
+                      guint                  n_construct_properties,
+                      GObjectConstructParam *construct_properties)
+{
+        CcPanel      *panel;
+
+        panel = CC_PANEL (G_OBJECT_CLASS (cc_panel_parent_class)->constructor (type,
+                                                                               n_construct_properties,
+                                                                               construct_properties));
+
+        return G_OBJECT (panel);
+}
+
+static void
+cc_panel_class_init (CcPanelClass *klass)
+{
+        GParamSpec      *pspec;
+        GObjectClass    *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->get_property = cc_panel_get_property;
+        object_class->set_property = cc_panel_set_property;
+        object_class->constructor = cc_panel_constructor;
+        object_class->finalize = cc_panel_finalize;
+
+        klass->active_changed = cc_panel_real_active_changed;
+
+        g_type_class_add_private (klass, sizeof (CcPanelPrivate));
+
+        signals [ACTIVE_CHANGED]
+                = g_signal_new ("active-changed",
+                                G_TYPE_FROM_CLASS (object_class),
+                                G_SIGNAL_RUN_FIRST,
+                                G_STRUCT_OFFSET (CcPanelClass, active_changed),
+                                NULL,
+                                NULL,
+                                g_cclosure_marshal_VOID__BOOLEAN,
+                                G_TYPE_NONE,
+                                1, G_TYPE_BOOLEAN);
+
+        g_object_class_install_property (object_class,
+                                         PROP_ID,
+                                         g_param_spec_string ("id",
+                                                              "id",
+                                                              "id",
+                                                              NULL,
+                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (object_class,
+                                         PROP_DISPLAY_NAME,
+                                         g_param_spec_string ("display-name",
+                                                              "display name",
+                                                              "display name",
+                                                              NULL,
+                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+        g_object_class_install_property (object_class,
+                                         PROP_CURRENT_PAGE,
+                                         g_param_spec_object ("current-page",
+                                                              "",
+                                                              "",
+                                                              CC_TYPE_PAGE,
+                                                              G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
+
+        pspec = g_param_spec_object ("shell",
+                                     "Shell",
+                                     "Shell",
+                                     CC_TYPE_SHELL,
+                                     G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS
+                                      | G_PARAM_CONSTRUCT_ONLY);
+
+        g_object_class_install_property (object_class, PROP_SHELL, pspec);
+
+}
+
+static void
+cc_panel_init (CcPanel *panel)
+{
+
+        panel->priv = CC_PANEL_GET_PRIVATE (panel);
+}
+
+static void
+cc_panel_finalize (GObject *object)
+{
+        CcPanel *panel;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (CC_IS_PANEL (object));
+
+        panel = CC_PANEL (object);
+
+        g_return_if_fail (panel->priv != NULL);
+
+        g_free (panel->priv->id);
+        g_free (panel->priv->display_name);
+
+        G_OBJECT_CLASS (cc_panel_parent_class)->finalize (object);
+}
+
+CcShell *
+cc_panel_get_shell (CcPanel *panel)
+{
+        return panel->priv->shell;
+}
diff --git a/capplets/common/cc-panel.h b/capplets/common/cc-panel.h
new file mode 100644
index 0000000..49d865d
--- /dev/null
+++ b/capplets/common/cc-panel.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2010 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#ifndef __CC_PANEL_H
+#define __CC_PANEL_H
+
+#include <glib-object.h>
+#include <gtk/gtk.h>
+#include "cc-shell.h"
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_PANEL         (cc_panel_get_type ())
+#define CC_PANEL(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), CC_TYPE_PANEL, CcPanel))
+#define CC_PANEL_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), CC_TYPE_PANEL, CcPanelClass))
+#define CC_IS_PANEL(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), CC_TYPE_PANEL))
+#define CC_IS_PANEL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), CC_TYPE_PANEL))
+#define CC_PANEL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), CC_TYPE_PANEL, CcPanelClass))
+
+#define CC_PANEL_EXTENSION_POINT_NAME "control-center-panel-1"
+
+typedef struct CcPanelPrivate CcPanelPrivate;
+
+typedef struct
+{
+        GtkAlignment    parent;
+        CcPanelPrivate *priv;
+} CcPanel;
+
+typedef struct
+{
+        GtkAlignmentClass   parent_class;
+
+        void (* active_changed)           (CcPanel *panel,
+                                           gboolean is_active);
+} CcPanelClass;
+
+GType               cc_panel_get_type               (void);
+
+gboolean            cc_panel_is_active              (CcPanel *panel);
+
+void                cc_panel_set_active             (CcPanel *panel,
+                                                     gboolean is_active);
+
+CcShell*            cc_panel_get_shell              (CcPanel *panel);
+
+
+G_END_DECLS
+
+#endif /* __CC_PANEL_H */
diff --git a/capplets/common/cc-shell.c b/capplets/common/cc-shell.c
new file mode 100644
index 0000000..a38f430
--- /dev/null
+++ b/capplets/common/cc-shell.c
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2010 Intel, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+#include "cc-shell.h"
+#include "cc-panel.h"
+
+G_DEFINE_ABSTRACT_TYPE (CcShell, cc_shell, G_TYPE_OBJECT)
+
+#define SHELL_PRIVATE(o) \
+  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_SHELL, CcShellPrivate))
+
+static void
+cc_shell_class_init (CcShellClass *klass)
+{
+}
+
+static void
+cc_shell_init (CcShell *self)
+{
+}
+
+gboolean
+cc_shell_set_panel (CcShell     *shell,
+                    const gchar *id)
+{
+  CcShellClass *class;
+
+  class = (CcShellClass *) G_OBJECT_GET_CLASS (shell);
+
+  return class->set_panel (shell, id);
+}
+
diff --git a/capplets/common/cc-shell.h b/capplets/common/cc-shell.h
new file mode 100644
index 0000000..e99eff9
--- /dev/null
+++ b/capplets/common/cc-shell.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2010 Intel, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+#ifndef _CC_SHELL_H
+#define _CC_SHELL_H
+
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_SHELL cc_shell_get_type()
+
+#define CC_SHELL(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
+  CC_TYPE_SHELL, CcShell))
+
+#define CC_SHELL_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST ((klass), \
+  CC_TYPE_SHELL, CcShellClass))
+
+#define CC_IS_SHELL(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
+  CC_TYPE_SHELL))
+
+#define CC_IS_SHELL_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
+  CC_TYPE_SHELL))
+
+#define CC_SHELL_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
+  CC_TYPE_SHELL, CcShellClass))
+
+
+typedef struct _CcShell CcShell;
+typedef struct _CcShellClass CcShellClass;
+typedef struct _CcShellPrivate CcShellPrivate;
+
+struct _CcShell
+{
+  GObject parent;
+
+  CcShellPrivate *priv;
+};
+
+struct _CcShellClass
+{
+  GObjectClass parent_class;
+
+  gboolean (*set_panel) (CcShell *shell, const gchar *id);
+};
+
+GType cc_shell_get_type (void) G_GNUC_CONST;
+
+gboolean cc_shell_set_panel (CcShell *shell, const gchar *id);
+
+G_END_DECLS
+
+#endif /* _CC_SHELL_H */
diff --git a/capplets/common/cc-theme-thumbnailer-helper.c b/capplets/common/cc-theme-thumbnailer-helper.c
new file mode 100644
index 0000000..3683f7e
--- /dev/null
+++ b/capplets/common/cc-theme-thumbnailer-helper.c
@@ -0,0 +1,67 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2010 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <locale.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <glib-object.h>
+
+#include "cc-theme-thumbnailer-slave.h"
+
+int
+main (int    argc,
+      char **argv)
+{
+        CcThemeThumbnailerSlave *slave;
+
+        bindtextdomain (GETTEXT_PACKAGE, GNOMELOCALEDIR);
+        textdomain (GETTEXT_PACKAGE);
+        setlocale (LC_ALL, "");
+
+        g_type_init ();
+        gtk_init (&argc, &argv);
+
+        slave = cc_theme_thumbnailer_slave_new ();
+        if (slave == NULL) {
+                goto out;
+        }
+
+        gtk_main ();
+
+        if (slave != NULL) {
+                g_object_unref (slave);
+        }
+
+ out:
+
+        return 0;
+}
diff --git a/capplets/common/cc-theme-thumbnailer-slave.c b/capplets/common/cc-theme-thumbnailer-slave.c
new file mode 100644
index 0000000..d890538
--- /dev/null
+++ b/capplets/common/cc-theme-thumbnailer-slave.c
@@ -0,0 +1,918 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2002 Jonathan Blandford
+ * Copyright (C) 2010 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+
+
+#ifdef HAVE_MUTTER
+
+#include <mutter-private/util.h>
+#include <mutter-private/theme.h>
+#include <mutter-private/theme-parser.h>
+#include <mutter-private/preview-widget.h>
+
+#else
+
+#include <metacity-private/util.h>
+#include <metacity-private/theme.h>
+#include <metacity-private/theme-parser.h>
+#include <metacity-private/preview-widget.h>
+
+#endif
+
+
+/* We have to #undef this as metacity #defines these. */
+#undef _
+#undef N_
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <glib/gstdio.h>
+#include <glib-object.h>
+
+#include "cc-theme-thumbnailer-slave.h"
+#include "gtkrc-utils.h"
+
+#define CC_THEME_THUMBNAILER_SLAVE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_THEME_THUMBNAILER_SLAVE, CcThemeThumbnailerSlavePrivate))
+
+#define THUMBNAIL_TYPE_META     "meta"
+#define THUMBNAIL_TYPE_GTK      "gtk"
+#define THUMBNAIL_TYPE_METACITY "metacity"
+#define THUMBNAIL_TYPE_ICON     "icon"
+
+#define META_THUMBNAIL_SIZE       128
+#define GTK_THUMBNAIL_SIZE         96
+#define METACITY_THUMBNAIL_WIDTH  120
+#define METACITY_THUMBNAIL_HEIGHT  60
+
+struct CcThemeThumbnailerSlavePrivate
+{
+        int                  status;
+        GByteArray          *type;
+        GByteArray          *control_theme_name;
+        GByteArray          *gtk_color_scheme;
+        GByteArray          *wm_theme_name;
+        GByteArray          *icon_theme_name;
+        GByteArray          *application_font;
+
+        GIOChannel          *channel;
+        guint                watch_id;
+};
+
+enum {
+        PROP_0,
+};
+
+static void     cc_theme_thumbnailer_slave_class_init  (CcThemeThumbnailerSlaveClass *klass);
+static void     cc_theme_thumbnailer_slave_init        (CcThemeThumbnailerSlave      *theme_thumbnailer_slave);
+static void     cc_theme_thumbnailer_slave_finalize    (GObject         *object);
+
+static gpointer theme_thumbnailer_slave_object = NULL;
+
+G_DEFINE_TYPE (CcThemeThumbnailerSlave, cc_theme_thumbnailer_slave, G_TYPE_OBJECT)
+
+/* Protocol */
+
+/* Our protocol is pretty simple.  The parent process will write several strings
+ * (separated by a '\000'). They are the widget theme, the wm theme, the icon
+ * theme, etc.  Then, it will wait for the child to write back the data.  The
+ * parent expects ICON_SIZE_WIDTH * ICON_SIZE_HEIGHT * 4 bytes of information.
+ * After that, the child is ready for the next theme to render.
+ */
+
+enum {
+        READY_FOR_THEME,
+        READING_TYPE,
+        READING_CONTROL_THEME_NAME,
+        READING_GTK_COLOR_SCHEME,
+        READING_WM_THEME_NAME,
+        READING_ICON_THEME_NAME,
+        READING_APPLICATION_FONT,
+        WRITING_PIXBUF_DATA
+};
+
+GQuark
+cc_theme_thumbnailer_slave_error_quark (void)
+{
+        static GQuark ret = 0;
+        if (ret == 0) {
+                ret = g_quark_from_static_string ("cc_theme_thumbnailer_slave_error");
+        }
+
+        return ret;
+}
+
+static void
+cc_theme_thumbnailer_slave_set_property (GObject      *object,
+                                         guint         prop_id,
+                                         const GValue  *value,
+                                         GParamSpec    *pspec)
+{
+        CcThemeThumbnailerSlave *self;
+
+        self = CC_THEME_THUMBNAILER_SLAVE (object);
+
+        switch (prop_id) {
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+cc_theme_thumbnailer_slave_get_property (GObject    *object,
+                                         guint       prop_id,
+                                         GValue     *value,
+                                         GParamSpec *pspec)
+{
+        CcThemeThumbnailerSlave *self;
+
+        self = CC_THEME_THUMBNAILER_SLAVE (object);
+
+        switch (prop_id) {
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+fake_expose_widget (GtkWidget    *widget,
+                    GdkPixmap    *pixmap,
+                    GdkRectangle *area)
+{
+        GdkWindow     *tmp_window;
+        GdkEventExpose event;
+
+        event.type = GDK_EXPOSE;
+        event.window = pixmap;
+        event.send_event = FALSE;
+        event.area = area ? *area : widget->allocation;
+        event.region = NULL;
+        event.count = 0;
+
+        tmp_window = widget->window;
+        widget->window = pixmap;
+        gtk_widget_send_expose (widget, (GdkEvent *) &event);
+        widget->window = tmp_window;
+}
+
+static void
+hbox_foreach (GtkWidget *widget,
+              gpointer   data)
+{
+        if (GTK_WIDGET_VISIBLE (widget)) {
+                gtk_widget_realize (widget);
+                gtk_widget_map (widget);
+                gtk_widget_ensure_style (widget);
+                fake_expose_widget (widget, (GdkPixmap *) data, NULL);
+        }
+}
+
+static void
+pixbuf_apply_mask_region (GdkPixbuf *pixbuf,
+                          GdkRegion *region)
+{
+        int     nchannels, rowstride, w, h;
+        guchar *pixels, *p;
+
+        g_return_if_fail (pixbuf);
+        g_return_if_fail (region);
+
+        nchannels = gdk_pixbuf_get_n_channels (pixbuf);
+        rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+        pixels = gdk_pixbuf_get_pixels (pixbuf);
+
+
+        /* we need an alpha channel ... */
+        if (!gdk_pixbuf_get_has_alpha (pixbuf) || nchannels != 4)
+                return;
+
+        for (w = 0; w < gdk_pixbuf_get_width (pixbuf); ++w) {
+                for (h = 0; h < gdk_pixbuf_get_height (pixbuf); ++h) {
+                        if (!gdk_region_point_in (region, w, h)) {
+                                p = pixels + h * rowstride + w * nchannels;
+                                if (G_BYTE_ORDER == G_BIG_ENDIAN)
+                                        p[0] = 0x0;
+                                else
+                                        p[3] = 0x0;
+                        }
+                }
+        }
+}
+
+static GdkPixbuf *
+create_folder_icon (char *icon_theme_name)
+{
+        GtkIconTheme *icon_theme;
+        GdkPixbuf    *folder_icon = NULL;
+        GtkIconInfo  *folder_icon_info;
+        char         *example_icon_name;
+        const char   *icon_names[5];
+        int           i;
+
+        icon_theme = gtk_icon_theme_new ();
+        gtk_icon_theme_set_custom_theme (icon_theme, icon_theme_name);
+
+        i = 0;
+        /* Get the Example icon name in the theme if specified */
+        example_icon_name = gtk_icon_theme_get_example_icon_name (icon_theme);
+        if (example_icon_name != NULL)
+                icon_names[i++] = example_icon_name;
+        icon_names[i++] = "x-directory-normal";
+        icon_names[i++] = "gnome-fs-directory";
+        icon_names[i++] = "folder";
+        icon_names[i++] = NULL;
+
+        folder_icon_info = gtk_icon_theme_choose_icon (icon_theme, icon_names, 48, GTK_ICON_LOOKUP_FORCE_SIZE);
+        if (folder_icon_info != NULL) {
+                folder_icon = gtk_icon_info_load_icon (folder_icon_info, NULL);
+                gtk_icon_info_free (folder_icon_info);
+        }
+
+        g_object_unref (icon_theme);
+        g_free (example_icon_name);
+
+        /* render the icon to the thumbnail */
+        if (folder_icon == NULL) {
+                GtkWidget *dummy;
+                dummy = gtk_label_new ("");
+
+                folder_icon = gtk_widget_render_icon (dummy,
+                                                      GTK_STOCK_MISSING_IMAGE,
+                                                      GTK_ICON_SIZE_DIALOG,
+                                                      NULL);
+
+                gtk_widget_destroy (dummy);
+        }
+
+        return folder_icon;
+}
+
+static GdkPixbuf *
+create_meta_theme_pixbuf (CcThemeThumbnailerSlave *slave)
+{
+        GtkWidget *window;
+        GtkWidget *preview;
+        GtkWidget *vbox;
+        GtkWidget *align;
+        GtkWidget *box;
+        GtkWidget *stock_button;
+        GtkWidget *checkbox;
+        GtkWidget *radio;
+
+        GtkRequisition requisition;
+        GtkAllocation  allocation;
+        GdkPixmap     *pixmap;
+        GdkVisual     *visual;
+        MetaFrameFlags flags;
+        MetaTheme     *theme;
+        GdkPixbuf     *pixbuf, *icon;
+        int            icon_width, icon_height;
+        GdkRegion     *region;
+
+        g_object_set (gtk_settings_get_default (),
+                      "gtk-theme-name", (char *) slave->priv->control_theme_name->data,
+                      "gtk-font-name", (char *) slave->priv->application_font->data,
+                      "gtk-icon-theme-name", (char *) slave->priv->icon_theme_name->data,
+                      "gtk-color-scheme", (char *) slave->priv->gtk_color_scheme->data,
+                      NULL);
+
+        theme = meta_theme_load ((char *) slave->priv->wm_theme_name->data, NULL);
+        if (theme == NULL)
+                return NULL;
+
+        /* Represent the icon theme */
+        icon = create_folder_icon ((char *) slave->priv->icon_theme_name->data);
+        icon_width = gdk_pixbuf_get_width (icon);
+        icon_height = gdk_pixbuf_get_height (icon);
+
+        /* Create a fake window */
+        flags = META_FRAME_ALLOWS_DELETE |
+                META_FRAME_ALLOWS_MENU |
+                META_FRAME_ALLOWS_MINIMIZE |
+                META_FRAME_ALLOWS_MAXIMIZE |
+                META_FRAME_ALLOWS_VERTICAL_RESIZE |
+                META_FRAME_ALLOWS_HORIZONTAL_RESIZE |
+                META_FRAME_HAS_FOCUS |
+                META_FRAME_ALLOWS_SHADE |
+                META_FRAME_ALLOWS_MOVE;
+
+        window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+        preview = meta_preview_new ();
+        gtk_container_add (GTK_CONTAINER (window), preview);
+        gtk_widget_realize (window);
+        gtk_widget_realize (preview);
+        vbox = gtk_vbox_new (FALSE, 6);
+        gtk_container_set_border_width (GTK_CONTAINER (vbox), 6);
+        gtk_container_add (GTK_CONTAINER (preview), vbox);
+        align = gtk_alignment_new (0, 0, 0.0, 0.0);
+        gtk_box_pack_start (GTK_BOX (vbox), align, FALSE, FALSE, 0);
+        stock_button = gtk_button_new_from_stock (GTK_STOCK_OPEN);
+        gtk_container_add (GTK_CONTAINER (align), stock_button);
+        box = gtk_hbox_new (FALSE, 0);
+        gtk_box_pack_start (GTK_BOX (vbox), box, FALSE, FALSE, 0);
+        checkbox = gtk_check_button_new ();
+        gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (checkbox), TRUE);
+        gtk_box_pack_start (GTK_BOX (box), checkbox, FALSE, FALSE, 0);
+        radio = gtk_radio_button_new (NULL);
+        gtk_box_pack_start (GTK_BOX (box), radio, FALSE, FALSE, 0);
+
+        gtk_widget_show_all (preview);
+        gtk_widget_realize (stock_button);
+        gtk_widget_realize (GTK_BIN (stock_button)->child);
+        gtk_widget_realize (checkbox);
+        gtk_widget_realize (radio);
+        gtk_widget_map (stock_button);
+        gtk_widget_map (GTK_BIN (stock_button)->child);
+        gtk_widget_map (checkbox);
+        gtk_widget_map (radio);
+
+        meta_preview_set_frame_flags (META_PREVIEW (preview), flags);
+        meta_preview_set_theme (META_PREVIEW (preview), theme);
+        meta_preview_set_title (META_PREVIEW (preview), "");
+
+        gtk_window_set_default_size (GTK_WINDOW (window), META_THUMBNAIL_SIZE, META_THUMBNAIL_SIZE);
+
+        gtk_widget_size_request (window, &requisition);
+        allocation.x = 0;
+        allocation.y = 0;
+        allocation.width = META_THUMBNAIL_SIZE;
+        allocation.height = META_THUMBNAIL_SIZE;
+        gtk_widget_size_allocate (window, &allocation);
+        gtk_widget_size_request (window, &requisition);
+
+        /* Create a pixmap */
+        visual = gtk_widget_get_visual (window);
+        pixmap = gdk_pixmap_new (NULL, META_THUMBNAIL_SIZE, META_THUMBNAIL_SIZE, visual->depth);
+        gdk_drawable_set_colormap (GDK_DRAWABLE (pixmap), gtk_widget_get_colormap (window));
+
+        /* Draw the window */
+        gtk_widget_ensure_style (window);
+        g_assert (window->style);
+        g_assert (window->style->font_desc);
+
+        fake_expose_widget (window, pixmap, NULL);
+        fake_expose_widget (preview, pixmap, NULL);
+        /* we call this again here because the preview sometimes draws into the area
+         * of the contents, see http://bugzilla.gnome.org/show_bug.cgi?id=351389 */
+        fake_expose_widget (window, pixmap, &vbox->allocation);
+        fake_expose_widget (stock_button, pixmap, NULL);
+        gtk_container_foreach (GTK_CONTAINER (GTK_BIN (GTK_BIN (stock_button)->child)->child),
+                               hbox_foreach,
+                               pixmap);
+        fake_expose_widget (GTK_BIN (stock_button)->child, pixmap, NULL);
+        fake_expose_widget (checkbox, pixmap, NULL);
+        fake_expose_widget (radio, pixmap, NULL);
+
+        pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, META_THUMBNAIL_SIZE, META_THUMBNAIL_SIZE);
+        gdk_pixbuf_get_from_drawable (pixbuf, pixmap, NULL, 0, 0, 0, 0, META_THUMBNAIL_SIZE, META_THUMBNAIL_SIZE);
+
+        /* Add the icon theme to the pixbuf */
+        gdk_pixbuf_composite (icon, pixbuf,
+                              vbox->allocation.x + vbox->allocation.width - icon_width - 5,
+                              vbox->allocation.y + vbox->allocation.height - icon_height - 5,
+                              icon_width, icon_height,
+                              vbox->allocation.x + vbox->allocation.width - icon_width - 5,
+                              vbox->allocation.y + vbox->allocation.height - icon_height - 5,
+                              1.0, 1.0, GDK_INTERP_BILINEAR, 255);
+        region = meta_preview_get_clip_region (META_PREVIEW (preview),
+                                               META_THUMBNAIL_SIZE, META_THUMBNAIL_SIZE);
+        pixbuf_apply_mask_region (pixbuf, region);
+        gdk_region_destroy (region);
+
+        g_object_unref (icon);
+        gtk_widget_destroy (window);
+        meta_theme_free (theme);
+
+        return pixbuf;
+}
+
+static GdkPixbuf *
+create_gtk_theme_pixbuf (CcThemeThumbnailerSlave *slave)
+{
+        GtkSettings   *settings;
+        GtkWidget     *window, *vbox, *box, *stock_button, *checkbox, *radio;
+        GtkRequisition requisition;
+        GtkAllocation  allocation;
+        GdkVisual     *visual;
+        GdkPixmap     *pixmap;
+        GdkPixbuf     *pixbuf, *retval;
+        int            width, height;
+
+        settings = gtk_settings_get_default ();
+        g_object_set (settings,
+                      "gtk-theme-name", (char *) slave->priv->control_theme_name->data,
+                      "gtk-color-scheme", (char *) slave->priv->gtk_color_scheme->data,
+                      NULL);
+
+        window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+
+        vbox = gtk_vbox_new (FALSE, 0);
+        gtk_container_add (GTK_CONTAINER (window), vbox);
+        box = gtk_hbox_new (FALSE, 6);
+        gtk_container_set_border_width (GTK_CONTAINER (box), 6);
+        gtk_box_pack_start (GTK_BOX (vbox), box, FALSE, FALSE, 0);
+        stock_button = gtk_button_new_from_stock (GTK_STOCK_OPEN);
+        gtk_box_pack_start (GTK_BOX (box), stock_button, FALSE, FALSE, 0);
+        checkbox = gtk_check_button_new ();
+        gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (checkbox), TRUE);
+        gtk_box_pack_start (GTK_BOX (box), checkbox, FALSE, FALSE, 0);
+        radio = gtk_radio_button_new_from_widget (NULL);
+        gtk_box_pack_start (GTK_BOX (box), radio, FALSE, FALSE, 0);
+
+        gtk_widget_show_all (vbox);
+        gtk_widget_realize (stock_button);
+        gtk_widget_realize (GTK_BIN (stock_button)->child);
+        gtk_widget_realize (checkbox);
+        gtk_widget_realize (radio);
+        gtk_widget_map (stock_button);
+        gtk_widget_map (GTK_BIN (stock_button)->child);
+        gtk_widget_map (checkbox);
+        gtk_widget_map (radio);
+
+        gtk_widget_size_request (window, &requisition);
+        allocation.x = 0;
+        allocation.y = 0;
+        allocation.width = requisition.width;
+        allocation.height = requisition.height;
+        gtk_widget_size_allocate (window, &allocation);
+        gtk_widget_size_request (window, &requisition);
+
+        /* Draw the window */
+        gtk_widget_ensure_style (window);
+        g_assert (window->style);
+        g_assert (window->style->font_desc);
+
+        gtk_window_get_size (GTK_WINDOW (window), &width, &height);
+
+        visual = gtk_widget_get_visual (window);
+        pixmap = gdk_pixmap_new (NULL, width, height, visual->depth);
+        gdk_drawable_set_colormap (GDK_DRAWABLE (pixmap), gtk_widget_get_colormap (window));
+
+        fake_expose_widget (window, pixmap, NULL);
+        fake_expose_widget (stock_button, pixmap, NULL);
+        gtk_container_foreach (GTK_CONTAINER (GTK_BIN (GTK_BIN (stock_button)->child)->child),
+                               hbox_foreach,
+                               pixmap);
+        fake_expose_widget (GTK_BIN (stock_button)->child, pixmap, NULL);
+        fake_expose_widget (checkbox, pixmap, NULL);
+        fake_expose_widget (radio, pixmap, NULL);
+
+        pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, width, height);
+        gdk_pixbuf_get_from_drawable (pixbuf, pixmap, NULL, 0, 0, 0, 0, width, height);
+
+        retval = gdk_pixbuf_scale_simple (pixbuf,
+                                          GTK_THUMBNAIL_SIZE,
+                                          (int) GTK_THUMBNAIL_SIZE * (((double) height) / ((double) width)),
+                                          GDK_INTERP_BILINEAR);
+        g_object_unref (pixbuf);
+        gtk_widget_destroy (window);
+
+        return retval;
+}
+
+static GdkPixbuf *
+create_metacity_theme_pixbuf (CcThemeThumbnailerSlave *slave)
+{
+        GtkWidget     *window, *preview, *dummy;
+        MetaFrameFlags flags;
+        MetaTheme     *theme;
+        GtkRequisition requisition;
+        GtkAllocation  allocation;
+        GdkVisual     *visual;
+        GdkPixmap     *pixmap;
+        GdkPixbuf     *pixbuf, *retval;
+        GdkRegion     *region;
+
+        theme = meta_theme_load ((char *) slave->priv->wm_theme_name->data, NULL);
+        if (theme == NULL)
+                return NULL;
+
+        flags = META_FRAME_ALLOWS_DELETE |
+                META_FRAME_ALLOWS_MENU |
+                META_FRAME_ALLOWS_MINIMIZE |
+                META_FRAME_ALLOWS_MAXIMIZE |
+                META_FRAME_ALLOWS_VERTICAL_RESIZE |
+                META_FRAME_ALLOWS_HORIZONTAL_RESIZE |
+                META_FRAME_HAS_FOCUS |
+                META_FRAME_ALLOWS_SHADE |
+                META_FRAME_ALLOWS_MOVE;
+
+        window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+        gtk_window_set_default_size (GTK_WINDOW (window),
+                                     (int) METACITY_THUMBNAIL_WIDTH * 1.2,
+                                     (int) METACITY_THUMBNAIL_HEIGHT * 1.2);
+
+        preview = meta_preview_new ();
+        meta_preview_set_frame_flags (META_PREVIEW (preview), flags);
+        meta_preview_set_theme (META_PREVIEW (preview), theme);
+        meta_preview_set_title (META_PREVIEW (preview), "");
+        gtk_container_add (GTK_CONTAINER (window), preview);
+
+        dummy = gtk_label_new ("");
+        gtk_container_add (GTK_CONTAINER (preview), dummy);
+
+        gtk_widget_realize (window);
+        gtk_widget_realize (preview);
+        gtk_widget_realize (dummy);
+        gtk_widget_show_all (preview);
+        gtk_widget_map (dummy);
+
+        gtk_widget_size_request (window, &requisition);
+        allocation.x = 0;
+        allocation.y = 0;
+        allocation.width = (int) METACITY_THUMBNAIL_WIDTH * 1.2;
+        allocation.height = (int) METACITY_THUMBNAIL_HEIGHT * 1.2;
+        gtk_widget_size_allocate (window, &allocation);
+        gtk_widget_size_request (window, &requisition);
+
+        /* Draw the window */
+        gtk_widget_ensure_style (window);
+        g_assert (window->style);
+        g_assert (window->style->font_desc);
+
+        /* Create a pixmap */
+        visual = gtk_widget_get_visual (window);
+        pixmap = gdk_pixmap_new (NULL,
+                                 (int) METACITY_THUMBNAIL_WIDTH * 1.2,
+                                 (int) METACITY_THUMBNAIL_HEIGHT * 1.2,
+                                 visual->depth);
+        gdk_drawable_set_colormap (GDK_DRAWABLE (pixmap), gtk_widget_get_colormap (window));
+
+        fake_expose_widget (window, pixmap, NULL);
+        fake_expose_widget (preview, pixmap, NULL);
+        fake_expose_widget (window, pixmap, &dummy->allocation);
+
+        pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB,
+                                 TRUE,
+                                 8,
+                                 (int) METACITY_THUMBNAIL_WIDTH * 1.2,
+                                 (int) METACITY_THUMBNAIL_HEIGHT * 1.2);
+        gdk_pixbuf_get_from_drawable (pixbuf,
+                                      pixmap,
+                                      NULL,
+                                      0, 0, 0, 0,
+                                      (int) METACITY_THUMBNAIL_WIDTH * 1.2,
+                                      (int) METACITY_THUMBNAIL_HEIGHT * 1.2);
+
+        region = meta_preview_get_clip_region (META_PREVIEW (preview),
+                                               METACITY_THUMBNAIL_WIDTH * 1.2,
+                                               METACITY_THUMBNAIL_HEIGHT * 1.2);
+        pixbuf_apply_mask_region (pixbuf, region);
+        gdk_region_destroy (region);
+
+
+        retval = gdk_pixbuf_scale_simple (pixbuf,
+                                          METACITY_THUMBNAIL_WIDTH,
+                                          METACITY_THUMBNAIL_HEIGHT,
+                                          GDK_INTERP_BILINEAR);
+        g_object_unref (pixbuf);
+
+        gtk_widget_destroy (window);
+        meta_theme_free (theme);
+        return retval;
+}
+
+static GdkPixbuf *
+create_icon_theme_pixbuf (CcThemeThumbnailerSlave *slave)
+{
+        return create_folder_icon ((char *) slave->priv->icon_theme_name->data);
+}
+
+
+static void
+handle_bytes (CcThemeThumbnailerSlave *slave,
+              const char              *buffer,
+              int                      bytes_read)
+{
+        const guint8 *ptr;
+
+        ptr = (guint8 *)buffer;
+
+        while (bytes_read > 0) {
+                guint8 *nil;
+
+                switch (slave->priv->status) {
+                case READY_FOR_THEME:
+                        slave->priv->status = READING_TYPE;
+                        /* fall through */
+                case READING_TYPE:
+                        nil = memchr (ptr, '\000', bytes_read);
+                        if (nil == NULL) {
+                                g_byte_array_append (slave->priv->type,
+                                                     ptr,
+                                                     bytes_read);
+                                bytes_read = 0;
+                        } else {
+                                g_byte_array_append (slave->priv->type,
+                                                     ptr,
+                                                     nil - ptr + 1);
+                                bytes_read -= (nil - ptr + 1);
+                                ptr = nil + 1;
+                                slave->priv->status = READING_CONTROL_THEME_NAME;
+                        }
+                        break;
+
+                case READING_CONTROL_THEME_NAME:
+                        nil = memchr (ptr, '\000', bytes_read);
+                        if (nil == NULL) {
+                                g_byte_array_append (slave->priv->control_theme_name,
+                                                     ptr,
+                                                     bytes_read);
+                                bytes_read = 0;
+                        } else {
+                                g_byte_array_append (slave->priv->control_theme_name,
+                                                     ptr,
+                                                     nil - ptr + 1);
+                                bytes_read -= (nil - ptr + 1);
+                                ptr = nil + 1;
+                                slave->priv->status = READING_GTK_COLOR_SCHEME;
+                        }
+                        break;
+
+                case READING_GTK_COLOR_SCHEME:
+                        nil = memchr (ptr, '\000', bytes_read);
+                        if (nil == NULL) {
+                                g_byte_array_append (slave->priv->gtk_color_scheme,
+                                                     ptr,
+                                                     bytes_read);
+                                bytes_read = 0;
+                        } else {
+                                g_byte_array_append (slave->priv->gtk_color_scheme,
+                                                     ptr,
+                                                     nil - ptr + 1);
+                                bytes_read -= (nil - ptr + 1);
+                                ptr = nil + 1;
+                                slave->priv->status = READING_WM_THEME_NAME;
+                        }
+                        break;
+
+                case READING_WM_THEME_NAME:
+                        nil = memchr (ptr, '\000', bytes_read);
+                        if (nil == NULL) {
+                                g_byte_array_append (slave->priv->wm_theme_name,
+                                                     ptr,
+                                                     bytes_read);
+                                bytes_read = 0;
+                        } else {
+                                g_byte_array_append (slave->priv->wm_theme_name,
+                                                     ptr,
+                                                     nil - ptr + 1);
+                                bytes_read -= (nil - ptr + 1);
+                                ptr = nil + 1;
+                                slave->priv->status = READING_ICON_THEME_NAME;
+                        }
+                        break;
+
+                case READING_ICON_THEME_NAME:
+                        nil = memchr (ptr, '\000', bytes_read);
+                        if (nil == NULL) {
+                                g_byte_array_append (slave->priv->icon_theme_name,
+                                                     ptr,
+                                                     bytes_read);
+                                bytes_read = 0;
+                        } else {
+                                g_byte_array_append (slave->priv->icon_theme_name,
+                                                     ptr,
+                                                     nil - ptr + 1);
+                                bytes_read -= (nil - ptr + 1);
+                                ptr = nil + 1;
+                                slave->priv->status = READING_APPLICATION_FONT;
+                        }
+                        break;
+
+                case READING_APPLICATION_FONT:
+                        nil = memchr (ptr, '\000', bytes_read);
+                        if (nil == NULL) {
+                                g_byte_array_append (slave->priv->application_font,
+                                                     ptr,
+                                                     bytes_read);
+                                bytes_read = 0;
+                        } else {
+                                g_byte_array_append (slave->priv->application_font,
+                                                     ptr,
+                                                     nil - ptr + 1);
+                                bytes_read -= (nil - ptr + 1);
+                                ptr = nil + 1;
+                                slave->priv->status = WRITING_PIXBUF_DATA;
+                        }
+                        break;
+
+                default:
+                        g_assert_not_reached ();
+                }
+        }
+}
+
+static gboolean
+message_from_master (GIOChannel              *source,
+                     GIOCondition             condition,
+                     CcThemeThumbnailerSlave *slave)
+{
+        gboolean finished = FALSE;
+
+        if (condition & G_IO_IN) {
+                char      buffer[1024];
+                GIOStatus status;
+                gsize     bytes_read;
+
+                status = g_io_channel_read_chars (source,
+                                                  buffer,
+                                                  1024,
+                                                  &bytes_read,
+                                                  NULL);
+
+                switch (status) {
+                case G_IO_STATUS_NORMAL:
+                        handle_bytes (slave, buffer, bytes_read);
+
+                        if (slave->priv->status == WRITING_PIXBUF_DATA) {
+                                GdkPixbuf  *pixbuf = NULL;
+                                int         i, rowstride;
+                                guchar     *pixels;
+                                int         width, height;
+                                const char *type;
+                                ssize_t     res;
+
+                                type = (const char *) slave->priv->type->data;
+
+                                if (!strcmp (type, THUMBNAIL_TYPE_META))
+                                        pixbuf = create_meta_theme_pixbuf (slave);
+                                else if (!strcmp (type, THUMBNAIL_TYPE_GTK))
+                                        pixbuf = create_gtk_theme_pixbuf (slave);
+                                else if (!strcmp (type, THUMBNAIL_TYPE_METACITY))
+                                        pixbuf = create_metacity_theme_pixbuf (slave);
+                                else if (!strcmp (type, THUMBNAIL_TYPE_ICON))
+                                        pixbuf = create_icon_theme_pixbuf (slave);
+                                else
+                                        g_assert_not_reached ();
+
+                                if (pixbuf == NULL) {
+                                        width = height = rowstride = 0;
+                                        pixels = NULL;
+                                } else {
+                                        width = gdk_pixbuf_get_width (pixbuf);
+                                        height = gdk_pixbuf_get_height (pixbuf);
+                                        rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+                                        pixels = gdk_pixbuf_get_pixels (pixbuf);
+                                }
+
+                                /* Write the pixbuf's size */
+                                res = write (STDOUT_FILENO, &width, sizeof (width));
+                                res = write (STDOUT_FILENO, &height, sizeof (height));
+
+                                for (i = 0; i < height; i++) {
+                                        res = write (STDOUT_FILENO,
+                                                     pixels + rowstride * i,
+                                                     width * gdk_pixbuf_get_n_channels (pixbuf));
+                                }
+
+                                if (pixbuf != NULL)
+                                        g_object_unref (pixbuf);
+
+                                g_byte_array_set_size (slave->priv->type, 0);
+                                g_byte_array_set_size (slave->priv->control_theme_name, 0);
+                                g_byte_array_set_size (slave->priv->gtk_color_scheme, 0);
+                                g_byte_array_set_size (slave->priv->wm_theme_name, 0);
+                                g_byte_array_set_size (slave->priv->icon_theme_name, 0);
+                                g_byte_array_set_size (slave->priv->application_font, 0);
+                                slave->priv->status = READY_FOR_THEME;
+                        }
+                        break;
+
+                case G_IO_STATUS_AGAIN:
+                        break;
+
+                case G_IO_STATUS_EOF:
+                case G_IO_STATUS_ERROR:
+                        finished = TRUE;
+                        break;
+
+                default:
+                        g_assert_not_reached ();
+                }
+        } else if (condition & G_IO_HUP) {
+                finished = TRUE;
+        }
+
+        if (finished) {
+                return FALSE;
+        }
+
+        return TRUE;
+}
+
+static void
+start_slave (CcThemeThumbnailerSlave *slave)
+{
+        slave->priv->status = READY_FOR_THEME;
+        slave->priv->type = g_byte_array_new ();
+        slave->priv->control_theme_name = g_byte_array_new ();
+        slave->priv->gtk_color_scheme = g_byte_array_new ();
+        slave->priv->wm_theme_name = g_byte_array_new ();
+        slave->priv->icon_theme_name = g_byte_array_new ();
+        slave->priv->application_font = g_byte_array_new ();
+
+        slave->priv->channel = g_io_channel_unix_new (STDIN_FILENO);
+        g_io_channel_set_flags (slave->priv->channel,
+                                g_io_channel_get_flags (slave->priv->channel) | G_IO_FLAG_NONBLOCK,
+                                NULL);
+
+        g_io_channel_set_encoding (slave->priv->channel, NULL, NULL);
+        g_io_add_watch (slave->priv->channel,
+                        G_IO_IN | G_IO_HUP,
+                        (GIOFunc) message_from_master,
+                        slave);
+}
+
+static GObject *
+cc_theme_thumbnailer_slave_constructor (GType                  type,
+                                        guint                  n_construct_properties,
+                                        GObjectConstructParam *construct_properties)
+{
+        CcThemeThumbnailerSlave *slave;
+
+        slave = CC_THEME_THUMBNAILER_SLAVE (G_OBJECT_CLASS (cc_theme_thumbnailer_slave_parent_class)->constructor (type,
+                                                                                                                               n_construct_properties,
+                                                                                                                               construct_properties));
+
+        start_slave (slave);
+
+        return G_OBJECT (slave);
+}
+
+static void
+cc_theme_thumbnailer_slave_class_init (CcThemeThumbnailerSlaveClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->get_property = cc_theme_thumbnailer_slave_get_property;
+        object_class->set_property = cc_theme_thumbnailer_slave_set_property;
+        object_class->constructor = cc_theme_thumbnailer_slave_constructor;
+        object_class->finalize = cc_theme_thumbnailer_slave_finalize;
+
+        g_type_class_add_private (klass, sizeof (CcThemeThumbnailerSlavePrivate));
+}
+
+static void
+cc_theme_thumbnailer_slave_init (CcThemeThumbnailerSlave *thumbnailer_slave)
+{
+
+        thumbnailer_slave->priv = CC_THEME_THUMBNAILER_SLAVE_GET_PRIVATE (thumbnailer_slave);
+}
+
+static void
+cc_theme_thumbnailer_slave_finalize (GObject *object)
+{
+        CcThemeThumbnailerSlave *theme_thumbnailer_slave;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (CC_IS_THEME_THUMBNAILER_SLAVE (object));
+
+        theme_thumbnailer_slave = CC_THEME_THUMBNAILER_SLAVE (object);
+
+        g_return_if_fail (theme_thumbnailer_slave->priv != NULL);
+
+        G_OBJECT_CLASS (cc_theme_thumbnailer_slave_parent_class)->finalize (object);
+}
+
+CcThemeThumbnailerSlave *
+cc_theme_thumbnailer_slave_new (void)
+{
+        if (theme_thumbnailer_slave_object != NULL) {
+                g_object_ref (theme_thumbnailer_slave_object);
+        } else {
+                theme_thumbnailer_slave_object = g_object_new (CC_TYPE_THEME_THUMBNAILER_SLAVE, NULL);
+                g_object_add_weak_pointer (theme_thumbnailer_slave_object,
+                                           (gpointer *) &theme_thumbnailer_slave_object);
+        }
+
+        return CC_THEME_THUMBNAILER_SLAVE (theme_thumbnailer_slave_object);
+}
diff --git a/capplets/common/cc-theme-thumbnailer-slave.h b/capplets/common/cc-theme-thumbnailer-slave.h
new file mode 100644
index 0000000..1db2d8f
--- /dev/null
+++ b/capplets/common/cc-theme-thumbnailer-slave.h
@@ -0,0 +1,65 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2010 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __CC_THEME_THUMBNAILER_SLAVE_H
+#define __CC_THEME_THUMBNAILER_SLAVE_H
+
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+#include "gnome-theme-info.h"
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_THEME_THUMBNAILER_SLAVE         (cc_theme_thumbnailer_slave_get_type ())
+#define CC_THEME_THUMBNAILER_SLAVE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), CC_TYPE_THEME_THUMBNAILER_SLAVE, CcThemeThumbnailerSlave))
+#define CC_THEME_THUMBNAILER_SLAVE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), CC_TYPE_THEME_THUMBNAILER_SLAVE, CcThemeThumbnailerSlaveClass))
+#define CC_IS_THEME_THUMBNAILER_SLAVE(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), CC_TYPE_THEME_THUMBNAILER_SLAVE))
+#define CC_IS_THEME_THUMBNAILER_SLAVE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), CC_TYPE_THEME_THUMBNAILER_SLAVE))
+#define CC_THEME_THUMBNAILER_SLAVE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), CC_TYPE_THEME_THUMBNAILER_SLAVE, CcThemeThumbnailerSlaveClass))
+
+typedef struct CcThemeThumbnailerSlavePrivate CcThemeThumbnailerSlavePrivate;
+
+typedef struct
+{
+        GObject                   parent;
+        CcThemeThumbnailerSlavePrivate *priv;
+} CcThemeThumbnailerSlave;
+
+typedef struct
+{
+        GObjectClass   parent_class;
+} CcThemeThumbnailerSlaveClass;
+
+typedef enum
+{
+         CC_THEME_THUMBNAILER_SLAVE_ERROR_GENERAL
+} CcThemeThumbnailerSlaveError;
+
+#define CC_THEME_THUMBNAILER_SLAVE_ERROR cc_theme_thumbnailer_slave_error_quark ()
+
+GQuark                cc_theme_thumbnailer_slave_error_quark           (void);
+GType                 cc_theme_thumbnailer_slave_get_type              (void);
+
+CcThemeThumbnailerSlave *  cc_theme_thumbnailer_slave_new                   (void);
+
+G_END_DECLS
+
+#endif /* __CC_THEME_THUMBNAILER_SLAVE_H */
diff --git a/capplets/common/cc-theme-thumbnailer.c b/capplets/common/cc-theme-thumbnailer.c
new file mode 100644
index 0000000..e06d552
--- /dev/null
+++ b/capplets/common/cc-theme-thumbnailer.c
@@ -0,0 +1,643 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2002 Jonathan Blandford
+ * Copyright (C) 2010 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <glib/gstdio.h>
+#include <glib-object.h>
+
+#include "cc-theme-thumbnailer.h"
+#include "gtkrc-utils.h"
+
+#define CC_THEME_THUMBNAILER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_THEME_THUMBNAILER, CcThemeThumbnailerPrivate))
+
+#define THUMBNAIL_TYPE_META     "meta"
+#define THUMBNAIL_TYPE_GTK      "gtk"
+#define THUMBNAIL_TYPE_METACITY "metacity"
+#define THUMBNAIL_TYPE_ICON     "icon"
+
+#define META_THUMBNAIL_SIZE       128
+#define GTK_THUMBNAIL_SIZE         96
+#define METACITY_THUMBNAIL_WIDTH  120
+#define METACITY_THUMBNAIL_HEIGHT  60
+
+typedef struct
+{
+        char                *thumbnail_type;
+        gpointer             theme_info;
+        CcThemeThumbnailFunc func;
+        gpointer             user_data;
+        GDestroyNotify       destroy;
+} ThemeQueueItem;
+
+struct CcThemeThumbnailerPrivate
+{
+        GPid                 child_pid;
+        int                  fd_to_factory;
+        int                  fd_from_factory;
+
+        GList               *theme_queue;
+
+        /* async data */
+        gboolean             set;
+        int                  thumbnail_width;
+        int                  thumbnail_height;
+        GByteArray          *data;
+        char                *theme_name;
+        CcThemeThumbnailFunc func;
+        gpointer             user_data;
+        GDestroyNotify       destroy;
+        GIOChannel          *channel;
+        guint                watch_id;
+};
+
+enum {
+        PROP_0,
+};
+
+static void     cc_theme_thumbnailer_class_init  (CcThemeThumbnailerClass *klass);
+static void     cc_theme_thumbnailer_init        (CcThemeThumbnailer      *theme_thumbnailer);
+static void     cc_theme_thumbnailer_finalize    (GObject         *object);
+
+static gpointer theme_thumbnailer_object = NULL;
+
+G_DEFINE_TYPE (CcThemeThumbnailer, cc_theme_thumbnailer, G_TYPE_OBJECT)
+
+/* Protocol */
+
+/* Our protocol is pretty simple.  The parent process will write several strings
+ * (separated by a '\000'). They are the widget theme, the wm theme, the icon
+ * theme, etc.  Then, it will wait for the child to write back the data.  The
+ * parent expects ICON_SIZE_WIDTH * ICON_SIZE_HEIGHT * 4 bytes of information.
+ * After that, the child is ready for the next theme to render.
+ */
+
+enum {
+        READY_FOR_THEME,
+        READING_TYPE,
+        READING_CONTROL_THEME_NAME,
+        READING_GTK_COLOR_SCHEME,
+        READING_WM_THEME_NAME,
+        READING_ICON_THEME_NAME,
+        READING_APPLICATION_FONT,
+        WRITING_PIXBUF_DATA
+};
+
+GQuark
+cc_theme_thumbnailer_error_quark (void)
+{
+        static GQuark ret = 0;
+        if (ret == 0) {
+                ret = g_quark_from_static_string ("cc_theme_thumbnailer_error");
+        }
+
+        return ret;
+}
+
+static void
+cc_theme_thumbnailer_set_property (GObject      *object,
+                                   guint         prop_id,
+                                   const GValue  *value,
+                                   GParamSpec    *pspec)
+{
+        CcThemeThumbnailer *self;
+
+        self = CC_THEME_THUMBNAILER (object);
+
+        switch (prop_id) {
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+cc_theme_thumbnailer_get_property (GObject    *object,
+                                   guint       prop_id,
+                                   GValue     *value,
+                                   GParamSpec *pspec)
+{
+        CcThemeThumbnailer *self;
+
+        self = CC_THEME_THUMBNAILER (object);
+
+        switch (prop_id) {
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+                break;
+        }
+}
+
+static void
+generate_next_in_queue (CcThemeThumbnailer *thumbnailer)
+{
+        ThemeQueueItem *item;
+
+        if (thumbnailer->priv->theme_queue == NULL)
+                return;
+
+        item = thumbnailer->priv->theme_queue->data;
+        thumbnailer->priv->theme_queue = g_list_delete_link (thumbnailer->priv->theme_queue,
+                                                             g_list_first (thumbnailer->priv->theme_queue));
+
+        if (strcmp (item->thumbnail_type, THUMBNAIL_TYPE_META) == 0)
+                cc_theme_thumbnailer_create_meta_async (thumbnailer,
+                                                        (GnomeThemeMetaInfo *) item->theme_info,
+                                                        item->func,
+                                                        item->user_data,
+                                                        item->destroy);
+        else if (strcmp (item->thumbnail_type, THUMBNAIL_TYPE_GTK) == 0)
+                cc_theme_thumbnailer_create_gtk_async (thumbnailer,
+                                                       (GnomeThemeInfo *) item->theme_info,
+                                                       item->func,
+                                                       item->user_data,
+                                                       item->destroy);
+        else if (strcmp (item->thumbnail_type, THUMBNAIL_TYPE_METACITY) == 0)
+                cc_theme_thumbnailer_create_metacity_async (thumbnailer,
+                                                            (GnomeThemeInfo *) item->theme_info,
+                                                            item->func,
+                                                            item->user_data,
+                                                            item->destroy);
+        else if (strcmp (item->thumbnail_type, THUMBNAIL_TYPE_ICON) == 0)
+                cc_theme_thumbnailer_create_icon_async (thumbnailer,
+                                                        (GnomeThemeIconInfo *) item->theme_info,
+                                                        item->func,
+                                                        item->user_data,
+                                                        item->destroy);
+
+        g_free (item);
+}
+
+static gboolean
+message_from_child (GIOChannel         *source,
+                    GIOCondition        condition,
+                    CcThemeThumbnailer *thumbnailer)
+{
+        gboolean finished = FALSE;
+
+        if (condition & G_IO_IN) {
+                char      buffer[1024];
+                GIOStatus status;
+                gsize     bytes_read;
+
+                if (thumbnailer->priv->set == FALSE)
+                        return TRUE;
+
+                status = g_io_channel_read_chars (source,
+                                                  buffer,
+                                                  1024,
+                                                  &bytes_read,
+                                                  NULL);
+                switch (status) {
+                case G_IO_STATUS_NORMAL:
+                        g_byte_array_append (thumbnailer->priv->data, (guchar *) buffer, bytes_read);
+
+                        if (thumbnailer->priv->thumbnail_width == -1
+                            && thumbnailer->priv->data->len >= 2 * sizeof (int)) {
+
+                                thumbnailer->priv->thumbnail_width = *((int *) thumbnailer->priv->data->data);
+                                thumbnailer->priv->thumbnail_height = *(((int *) thumbnailer->priv->data->data) + 1);
+                                g_byte_array_remove_range (thumbnailer->priv->data, 0, 2 * sizeof (int));
+                        }
+
+                        if (thumbnailer->priv->thumbnail_width >= 0
+                            && thumbnailer->priv->data->len == thumbnailer->priv->thumbnail_width * thumbnailer->priv->thumbnail_height * 4) {
+                                GdkPixbuf *pixbuf = NULL;
+
+                                if (thumbnailer->priv->thumbnail_width > 0) {
+                                        char *pixels;
+                                        int   i, rowstride;
+
+                                        pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB,
+                                                                 TRUE,
+                                                                 8,
+                                                                 thumbnailer->priv->thumbnail_width,
+                                                                 thumbnailer->priv->thumbnail_height);
+                                        pixels = (char *) gdk_pixbuf_get_pixels (pixbuf);
+                                        rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+
+                                        for (i = 0; i < thumbnailer->priv->thumbnail_height; ++i)
+                                                memcpy (pixels + rowstride * i,
+                                                        thumbnailer->priv->data->data + 4 * thumbnailer->priv->thumbnail_width * i,
+                                                        thumbnailer->priv->thumbnail_width * 4);
+                                }
+
+                                /* callback function needs to ref the pixbuf if it wants to keep it */
+                                (* thumbnailer->priv->func) (pixbuf,
+                                                             thumbnailer->priv->theme_name,
+                                                             thumbnailer->priv->user_data);
+
+                                if (thumbnailer->priv->destroy)
+                                        (* thumbnailer->priv->destroy) (thumbnailer->priv->user_data);
+
+                                if (pixbuf)
+                                        g_object_unref (pixbuf);
+
+                                /* Clean up async_data */
+                                g_free (thumbnailer->priv->theme_name);
+                                g_source_remove (thumbnailer->priv->watch_id);
+                                g_io_channel_unref (thumbnailer->priv->channel);
+
+                                /* reset async_data */
+                                thumbnailer->priv->thumbnail_width = -1;
+                                thumbnailer->priv->thumbnail_height = -1;
+                                thumbnailer->priv->theme_name = NULL;
+                                thumbnailer->priv->channel = NULL;
+                                thumbnailer->priv->func = NULL;
+                                thumbnailer->priv->user_data = NULL;
+                                thumbnailer->priv->destroy = NULL;
+                                thumbnailer->priv->set = FALSE;
+                                g_byte_array_set_size (thumbnailer->priv->data, 0);
+
+                                generate_next_in_queue (thumbnailer);
+                        }
+                        break;
+
+                case G_IO_STATUS_AGAIN:
+                        break;
+
+                case G_IO_STATUS_EOF:
+                case G_IO_STATUS_ERROR:
+                        finished = TRUE;
+                        break;
+
+                default:
+                        g_assert_not_reached ();
+                }
+        } else if (condition & G_IO_HUP) {
+                finished = TRUE;
+        }
+
+        if (finished) {
+                return FALSE;
+        }
+
+        return TRUE;
+}
+
+static void
+send_thumbnail_request (CcThemeThumbnailer *thumbnailer,
+                        char               *thumbnail_type,
+                        char               *gtk_theme_name,
+                        char               *gtk_color_scheme,
+                        char               *metacity_theme_name,
+                        char               *icon_theme_name,
+                        char               *application_font)
+{
+        ssize_t res;
+
+        res = write (thumbnailer->priv->fd_to_factory,
+                     thumbnail_type,
+                     strlen (thumbnail_type) + 1);
+
+        if (gtk_theme_name != NULL)
+                res = write (thumbnailer->priv->fd_to_factory,
+                             gtk_theme_name,
+                             strlen (gtk_theme_name) + 1);
+        else
+                res = write (thumbnailer->priv->fd_to_factory,
+                             "",
+                             1);
+
+        if (gtk_color_scheme != NULL)
+                res = write (thumbnailer->priv->fd_to_factory,
+                             gtk_color_scheme,
+                             strlen (gtk_color_scheme) + 1);
+        else
+                res = write (thumbnailer->priv->fd_to_factory,
+                             "",
+                             1);
+
+        if (metacity_theme_name != NULL)
+                res = write (thumbnailer->priv->fd_to_factory,
+                             metacity_theme_name,
+                             strlen (metacity_theme_name) + 1);
+        else
+                res = write (thumbnailer->priv->fd_to_factory,
+                             "",
+                             1);
+
+        if (icon_theme_name != NULL)
+                res = write (thumbnailer->priv->fd_to_factory,
+                             icon_theme_name,
+                             strlen (icon_theme_name) + 1);
+        else
+                res = write (thumbnailer->priv->fd_to_factory,
+                             "",
+                             1);
+
+        if (application_font != NULL)
+                res = write (thumbnailer->priv->fd_to_factory,
+                             application_font,
+                             strlen (application_font) + 1);
+        else
+                res = write (thumbnailer->priv->fd_to_factory,
+                             "Sans 10",
+                             strlen ("Sans 10") + 1);
+
+        /* FIXME: check the return values */
+}
+
+static void
+generate_thumbnail_async (CcThemeThumbnailer  *thumbnailer,
+                          gpointer             theme_info,
+                          char                *theme_name,
+                          char                *thumbnail_type,
+                          char                *gtk_theme_name,
+                          char                *gtk_color_scheme,
+                          char                *metacity_theme_name,
+                          char                *icon_theme_name,
+                          char                *application_font,
+                          CcThemeThumbnailFunc func,
+                          gpointer             user_data,
+                          GDestroyNotify       destroy)
+{
+        if (thumbnailer->priv->set) {
+                ThemeQueueItem *item;
+
+                item = g_new0 (ThemeQueueItem, 1);
+                item->thumbnail_type = thumbnail_type;
+                item->theme_info = theme_info;
+                item->func = func;
+                item->user_data = user_data;
+                item->destroy = destroy;
+
+                thumbnailer->priv->theme_queue = g_list_append (thumbnailer->priv->theme_queue, item);
+
+                return;
+        }
+
+        if (!thumbnailer->priv->fd_to_factory
+            || !thumbnailer->priv->fd_from_factory) {
+
+                (* func) (NULL, theme_name, user_data);
+
+                if (destroy)
+                        (* destroy) (user_data);
+
+                return;
+        }
+
+        if (thumbnailer->priv->channel == NULL) {
+                thumbnailer->priv->channel = g_io_channel_unix_new (thumbnailer->priv->fd_from_factory);
+                g_io_channel_set_flags (thumbnailer->priv->channel,
+                                        g_io_channel_get_flags (thumbnailer->priv->channel)
+                                        | G_IO_FLAG_NONBLOCK,
+                                        NULL);
+                g_io_channel_set_encoding (thumbnailer->priv->channel, NULL, NULL);
+                thumbnailer->priv->watch_id = g_io_add_watch (thumbnailer->priv->channel,
+                                                              G_IO_IN | G_IO_HUP,
+                                                              (GIOFunc) message_from_child,
+                                                              thumbnailer);
+        }
+
+        thumbnailer->priv->set = TRUE;
+        thumbnailer->priv->thumbnail_width = -1;
+        thumbnailer->priv->thumbnail_height = -1;
+        thumbnailer->priv->theme_name = g_strdup (theme_name);
+        thumbnailer->priv->func = func;
+        thumbnailer->priv->user_data = user_data;
+        thumbnailer->priv->destroy = destroy;
+
+        send_thumbnail_request (thumbnailer,
+                                thumbnail_type,
+                                gtk_theme_name,
+                                gtk_color_scheme,
+                                metacity_theme_name,
+                                icon_theme_name,
+                                application_font);
+}
+
+void
+cc_theme_thumbnailer_create_meta_async (CcThemeThumbnailer  *thumbnailer,
+                                        GnomeThemeMetaInfo  *theme_info,
+                                        CcThemeThumbnailFunc func,
+                                        gpointer             user_data,
+                                        GDestroyNotify       destroy)
+{
+        generate_thumbnail_async (thumbnailer,
+                                  theme_info,
+                                  theme_info->name,
+                                  THUMBNAIL_TYPE_META,
+                                  theme_info->gtk_theme_name,
+                                  theme_info->gtk_color_scheme,
+                                  theme_info->metacity_theme_name,
+                                  theme_info->icon_theme_name,
+                                  theme_info->application_font,
+                                  func,
+                                  user_data,
+                                  destroy);
+}
+
+void
+cc_theme_thumbnailer_create_gtk_async (CcThemeThumbnailer   *thumbnailer,
+                                       GnomeThemeInfo       *theme_info,
+                                       CcThemeThumbnailFunc  func,
+                                       gpointer              user_data,
+                                       GDestroyNotify        destroy)
+{
+        char *scheme;
+
+        scheme = gtkrc_get_color_scheme_for_theme (theme_info->name);
+
+        generate_thumbnail_async (thumbnailer,
+                                  theme_info,
+                                  theme_info->name,
+                                  THUMBNAIL_TYPE_GTK,
+                                  theme_info->name,
+                                  scheme,
+                                  NULL,
+                                  NULL,
+                                  NULL,
+                                  func,
+                                  user_data,
+                                  destroy);
+        g_free (scheme);
+}
+
+void
+cc_theme_thumbnailer_create_metacity_async (CcThemeThumbnailer  *thumbnailer,
+                                            GnomeThemeInfo      *theme_info,
+                                            CcThemeThumbnailFunc func,
+                                            gpointer             user_data,
+                                            GDestroyNotify       destroy)
+{
+        generate_thumbnail_async (thumbnailer,
+                                  theme_info,
+                                  theme_info->name,
+                                  THUMBNAIL_TYPE_METACITY,
+                                  NULL,
+                                  NULL,
+                                  theme_info->name,
+                                  NULL,
+                                  NULL,
+                                  func,
+                                  user_data,
+                                  destroy);
+}
+
+void
+cc_theme_thumbnailer_create_icon_async (CcThemeThumbnailer  *thumbnailer,
+                                        GnomeThemeIconInfo  *theme_info,
+                                        CcThemeThumbnailFunc func,
+                                        gpointer             user_data,
+                                        GDestroyNotify       destroy)
+{
+        generate_thumbnail_async (thumbnailer,
+                                  theme_info,
+                                  theme_info->name,
+                                  THUMBNAIL_TYPE_ICON,
+                                  NULL,
+                                  NULL,
+                                  NULL,
+                                  theme_info->name,
+                                  NULL,
+                                  func,
+                                  user_data,
+                                  destroy);
+}
+
+static void
+create_server (CcThemeThumbnailer *thumbnailer)
+{
+        gboolean res;
+        int      argc;
+        char   **argv;
+        GError  *error;
+
+        g_shell_parse_argv (LIBEXECDIR "/cc-theme-thumbnailer-helper", &argc, &argv, NULL);
+
+        error = NULL;
+        res = g_spawn_async_with_pipes (NULL,
+                                        argv,
+                                        NULL,
+                                        G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD,
+                                        NULL,
+                                        thumbnailer,
+                                        &thumbnailer->priv->child_pid,
+                                        &thumbnailer->priv->fd_to_factory,
+                                        &thumbnailer->priv->fd_from_factory,
+                                        NULL,
+                                        &error);
+        if (! res) {
+                g_debug ("Could not start command '%s': %s", argv[0], error->message);
+                g_error_free (error);
+                g_strfreev (argv);
+                return;
+        }
+}
+
+void
+cc_theme_thumbnailer_start (CcThemeThumbnailer  *thumbnailer)
+{
+        if (thumbnailer->priv->child_pid > 0)
+                return;
+
+        create_server (thumbnailer);
+}
+
+void
+cc_theme_thumbnailer_stop (CcThemeThumbnailer  *thumbnailer)
+{
+        if (thumbnailer->priv->child_pid <= 0)
+                return;
+
+        /* FIXME: */
+}
+
+static GObject *
+cc_theme_thumbnailer_constructor (GType                  type,
+                                  guint                  n_construct_properties,
+                                  GObjectConstructParam *construct_properties)
+{
+        CcThemeThumbnailer *thumbnailer;
+
+        thumbnailer = CC_THEME_THUMBNAILER (G_OBJECT_CLASS (cc_theme_thumbnailer_parent_class)->constructor (type,
+                                                                                                                   n_construct_properties,
+                                                                                                                   construct_properties));
+
+        /* FIXME: should probably be async */
+        cc_theme_thumbnailer_start (thumbnailer);
+
+        return G_OBJECT (thumbnailer);
+}
+
+static void
+cc_theme_thumbnailer_class_init (CcThemeThumbnailerClass *klass)
+{
+        GObjectClass   *object_class = G_OBJECT_CLASS (klass);
+
+        object_class->get_property = cc_theme_thumbnailer_get_property;
+        object_class->set_property = cc_theme_thumbnailer_set_property;
+        object_class->constructor = cc_theme_thumbnailer_constructor;
+        object_class->finalize = cc_theme_thumbnailer_finalize;
+
+        g_type_class_add_private (klass, sizeof (CcThemeThumbnailerPrivate));
+}
+
+static void
+cc_theme_thumbnailer_init (CcThemeThumbnailer *thumbnailer)
+{
+
+        thumbnailer->priv = CC_THEME_THUMBNAILER_GET_PRIVATE (thumbnailer);
+
+        thumbnailer->priv->set = FALSE;
+        thumbnailer->priv->data = g_byte_array_new ();
+}
+
+static void
+cc_theme_thumbnailer_finalize (GObject *object)
+{
+        CcThemeThumbnailer *theme_thumbnailer;
+
+        g_return_if_fail (object != NULL);
+        g_return_if_fail (CC_IS_THEME_THUMBNAILER (object));
+
+        theme_thumbnailer = CC_THEME_THUMBNAILER (object);
+
+        g_return_if_fail (theme_thumbnailer->priv != NULL);
+
+        G_OBJECT_CLASS (cc_theme_thumbnailer_parent_class)->finalize (object);
+}
+
+CcThemeThumbnailer *
+cc_theme_thumbnailer_new (void)
+{
+        if (theme_thumbnailer_object != NULL) {
+                g_object_ref (theme_thumbnailer_object);
+        } else {
+                theme_thumbnailer_object = g_object_new (CC_TYPE_THEME_THUMBNAILER, NULL);
+                g_object_add_weak_pointer (theme_thumbnailer_object,
+                                           (gpointer *) &theme_thumbnailer_object);
+        }
+
+        return CC_THEME_THUMBNAILER (theme_thumbnailer_object);
+}
diff --git a/capplets/common/cc-theme-thumbnailer.h b/capplets/common/cc-theme-thumbnailer.h
new file mode 100644
index 0000000..db3f344
--- /dev/null
+++ b/capplets/common/cc-theme-thumbnailer.h
@@ -0,0 +1,93 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2010 William Jon McCann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __CC_THEME_THUMBNAILER_H
+#define __CC_THEME_THUMBNAILER_H
+
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+#include "gnome-theme-info.h"
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_THEME_THUMBNAILER         (cc_theme_thumbnailer_get_type ())
+#define CC_THEME_THUMBNAILER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), CC_TYPE_THEME_THUMBNAILER, CcThemeThumbnailer))
+#define CC_THEME_THUMBNAILER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), CC_TYPE_THEME_THUMBNAILER, CcThemeThumbnailerClass))
+#define CC_IS_THEME_THUMBNAILER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), CC_TYPE_THEME_THUMBNAILER))
+#define CC_IS_THEME_THUMBNAILER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), CC_TYPE_THEME_THUMBNAILER))
+#define CC_THEME_THUMBNAILER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), CC_TYPE_THEME_THUMBNAILER, CcThemeThumbnailerClass))
+
+typedef struct CcThemeThumbnailerPrivate CcThemeThumbnailerPrivate;
+
+typedef struct
+{
+        GObject                   parent;
+        CcThemeThumbnailerPrivate *priv;
+} CcThemeThumbnailer;
+
+typedef struct
+{
+        GObjectClass   parent_class;
+} CcThemeThumbnailerClass;
+
+typedef enum
+{
+         CC_THEME_THUMBNAILER_ERROR_GENERAL
+} CcThemeThumbnailerError;
+
+#define CC_THEME_THUMBNAILER_ERROR cc_theme_thumbnailer_error_quark ()
+
+typedef void (* CcThemeThumbnailFunc)          (GdkPixbuf          *pixbuf,
+                                                char               *theme_name,
+                                                gpointer            data);
+
+GQuark                cc_theme_thumbnailer_error_quark           (void);
+GType                 cc_theme_thumbnailer_get_type              (void);
+
+CcThemeThumbnailer *  cc_theme_thumbnailer_new                   (void);
+
+void                  cc_theme_thumbnailer_start                 (CcThemeThumbnailer  *thumbnailer);
+void                  cc_theme_thumbnailer_stop                  (CcThemeThumbnailer  *thumbnailer);
+
+void                  cc_theme_thumbnailer_create_meta_async     (CcThemeThumbnailer  *thumbnailer,
+                                                                  GnomeThemeMetaInfo  *theme_info,
+                                                                  CcThemeThumbnailFunc func,
+                                                                  gpointer             data,
+                                                                  GDestroyNotify       destroy);
+void                  cc_theme_thumbnailer_create_gtk_async      (CcThemeThumbnailer  *thumbnailer,
+                                                                  GnomeThemeInfo      *theme_info,
+                                                                  CcThemeThumbnailFunc func,
+                                                                  gpointer             data,
+                                                                  GDestroyNotify       destroy);
+void                  cc_theme_thumbnailer_create_metacity_async (CcThemeThumbnailer  *thumbnailer,
+                                                                  GnomeThemeInfo      *theme_info,
+                                                                  CcThemeThumbnailFunc func,
+                                                                  gpointer             data,
+                                                                  GDestroyNotify       destroy);
+void                  cc_theme_thumbnailer_create_icon_async     (CcThemeThumbnailer  *thumbnailer,
+                                                                  GnomeThemeIconInfo  *theme_info,
+                                                                  CcThemeThumbnailFunc func,
+                                                                  gpointer             data,
+                                                                  GDestroyNotify       destroy);
+
+G_END_DECLS
+
+#endif /* __CC_THEME_THUMBNAILER_H */
diff --git a/capplets/common/file-transfer-dialog.c b/capplets/common/file-transfer-dialog.c
index 34f415b..fcc3d39 100644
--- a/capplets/common/file-transfer-dialog.c
+++ b/capplets/common/file-transfer-dialog.c
@@ -25,7 +25,7 @@
 #endif
 
 #include <glib.h>
-#include <glib/gi18n.h>
+#include <glib/gi18n-lib.h>
 #include <gtk/gtk.h>
 #include <gio/gio.h>
 #include <limits.h>
diff --git a/capplets/common/gconf-property-editor.c b/capplets/common/gconf-property-editor.c
index 31f9e0e..8c403e3 100644
--- a/capplets/common/gconf-property-editor.c
+++ b/capplets/common/gconf-property-editor.c
@@ -25,6 +25,8 @@
 # include "config.h"
 #endif
 
+#include <glib/gi18n-lib.h>
+
 #include <string.h>
 #include <stdarg.h>
 #include <stdlib.h>
diff --git a/capplets/common/gconf-property-editor.h b/capplets/common/gconf-property-editor.h
index 5f39c7e..60b6e45 100644
--- a/capplets/common/gconf-property-editor.h
+++ b/capplets/common/gconf-property-editor.h
@@ -25,7 +25,6 @@
 #define __GCONF_PROPERTY_EDITOR_H
 
 #include <gtk/gtk.h>
-#include <glib/gi18n.h>
 #include <gconf/gconf-client.h>
 #include <gconf/gconf-changeset.h>
 
diff --git a/capplets/common/gnome-theme-info.c b/capplets/common/gnome-theme-info.c
index efe4a58..0617003 100644
--- a/capplets/common/gnome-theme-info.c
+++ b/capplets/common/gnome-theme-info.c
@@ -5,7 +5,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <dirent.h>
-#include <glib/gi18n.h>
+#include <glib/gi18n-lib.h>
 #include <gmodule.h>
 #include <gtk/gtk.h>
 #include <gdk/gdkx.h>
diff --git a/capplets/common/libgnome-control-center-extension-uninstalled.pc.in b/capplets/common/libgnome-control-center-extension-uninstalled.pc.in
new file mode 100644
index 0000000..fbf6c2b
--- /dev/null
+++ b/capplets/common/libgnome-control-center-extension-uninstalled.pc.in
@@ -0,0 +1,12 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+extensiondir=@libdir@/control-center-1/extensions
+
+Name: libgnome-control-center-extension
+Description: A library to create GNOME Control Center extensions
+Version: @VERSION@
+Requires: glib-2.0 gtk+-2.0
+Libs: ${pc_top_builddir}/${pcfiledir}/libgnome-control-center-extension.la
+Cflags: -I${pc_top_builddir}/${pcfiledir}/..
diff --git a/capplets/common/libgnome-control-center-extension.pc.in b/capplets/common/libgnome-control-center-extension.pc.in
new file mode 100644
index 0000000..5e8637f
--- /dev/null
+++ b/capplets/common/libgnome-control-center-extension.pc.in
@@ -0,0 +1,12 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+extensiondir=@libdir@/control-center-1/extensions
+
+Name: libgnome-control-center-extension
+Description: A library to create GNOME Control Center extensions
+Version: @VERSION@
+Requires: glib-2.0 gio-2.0 gtk+-2.0
+Libs: -L${libdir} -lgnome-control-center-extension
+Cflags: -I${includedir}/gnome-control-center-1
diff --git a/capplets/common/theme-thumbnail.c b/capplets/common/theme-thumbnail.c
index 094cb8e..71ca544 100644
--- a/capplets/common/theme-thumbnail.c
+++ b/capplets/common/theme-thumbnail.c
@@ -1,10 +1,23 @@
 #include <config.h>
 #include <unistd.h>
 #include <string.h>
+
+#ifdef HAVE_MUTTER
+
+#include <mutter-private/util.h>
+#include <mutter-private/theme.h>
+#include <mutter-private/theme-parser.h>
+#include <mutter-private/preview-widget.h>
+
+#else
+
 #include <metacity-private/util.h>
 #include <metacity-private/theme.h>
 #include <metacity-private/theme-parser.h>
 #include <metacity-private/preview-widget.h>
+
+#endif
+
 #include <signal.h>
 #include <errno.h>
 #include <math.h>
diff --git a/capplets/display/Makefile.am b/capplets/display/Makefile.am
index 14bba49..86226db 100644
--- a/capplets/display/Makefile.am
+++ b/capplets/display/Makefile.am
@@ -15,7 +15,7 @@ gnome_display_properties_SOURCES =	\
 
 gnome_display_properties_LDFLAGS = -export-dynamic
 gnome_display_properties_LDADD = \
-	$(top_builddir)/capplets/common/libcommon.la \
+	$(GNOMECC_CAPPLETS_LIBS) \
 	$(DISPLAY_CAPPLET_LIBS)
 
 @INTLTOOL_DESKTOP_RULE@
diff --git a/capplets/keyboard/gnome-keyboard-properties.c b/capplets/keyboard/gnome-keyboard-properties.c
index d2aef71..633b2db 100644
--- a/capplets/keyboard/gnome-keyboard-properties.c
+++ b/capplets/keyboard/gnome-keyboard-properties.c
@@ -29,6 +29,7 @@
 #endif
 
 #include <gconf/gconf-client.h>
+#include <glib/gi18n.h>
 
 #include "capplet-util.h"
 #include "gconf-property-editor.h"
diff --git a/configure.ac b/configure.ac
index f2984c3..4cbebc5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -99,11 +99,10 @@ COMMON_MODULES="gtk+-2.0 >= 2.18.0 dnl
  gnome-desktop-2.0 >= 2.29.4"
 PKG_CHECK_MODULES(CAPPLET, $COMMON_MODULES)
 PKG_CHECK_MODULES(GNOMECC, $COMMON_MODULES libgnome-menu >= 2.10.1)
-PKG_CHECK_MODULES(GNOMECC_SHELL, $COMMON_MODULES libgnome-menu unique-1.0)
+PKG_CHECK_MODULES(GNOMECC_SHELL, $COMMON_MODULES libgnome-menu unique-1.0 gio-unix-2.0)
 PKG_CHECK_MODULES(DBUS, dbus-1 dbus-glib-1)
 PKG_CHECK_MODULES(GNOME_DESKTOP, gnome-desktop-2.0)
 PKG_CHECK_MODULES(DEFAULT_APPLICATIONS_CAPPLET, libxml-2.0)
-PKG_CHECK_MODULES(METACITY, libmetacity-private >= 2.23.1)
 PKG_CHECK_MODULES(TYPING, glib-2.0 > 2.11 gconf-2.0 gtk+-2.0)
 PKG_CHECK_MODULES(GSD_DBUS, gnome-settings-daemon)
 PKG_CHECK_MODULES(GIO, gio-2.0)
@@ -139,6 +138,24 @@ AM_CONDITIONAL(HAVE_LIBSLAB, [test $have_libslab = yes -o $have_libslab_deps = y
 AM_CONDITIONAL(HAVE_LIBSLAB_DEPS, [test $have_libslab_deps = yes])
 AM_CONDITIONAL(LIBSLAB_FOR_INTERNAL_USE, test "yes" = "yes")
 
+dnl ================================================================
+dnl Extensions
+dnl ================================================================
+
+PKG_CHECK_MODULES(EXTENSION_COMMON, $COMMON_MODULES)
+
+EXTENSION_LIBTOOL_FLAGS="-export_dynamic -avoid-version -module -no-undefined -export-symbols-regex '^g_io_module_(load|unload)'"
+AC_SUBST(EXTENSION_LIBTOOL_FLAGS)
+
+EXTENSIONSDIR="${libdir}/control-center-1/extensions"
+AC_SUBST(EXTENSIONSDIR)
+
+EXTENSION_CFLAGS="-I\$(top_srcdir)/capplets/common"
+AC_SUBST(EXTENSION_CFLAGS)
+
+EXTENSION_LIBS="\$(top_builddir)/capplets/common/libgnome-control-center-extension.la"
+AC_SUBST(EXTENSION_LIBS)
+
 dnl
 dnl Check for Xft version 2; we build in extra functionality to the font capplet
 dnl when we have it.
@@ -233,6 +250,28 @@ fi
 AM_CONDITIONAL(BUILD_ABOUTME, test "x$enable_aboutme" = "xyes")
 
 dnl ==============================================
+dnl ==============================================
+dnl Check the window manager we need to work with
+dnl ==============================================
+
+AC_ARG_WITH([window_manager],
+            [AS_HELP_STRING([--with-window-manager],
+                            [specify which window manager to support (metacity, mutter)])],
+            [with_window_manager=${withval}],
+            [with_window_manager=metacity])
+
+AS_IF([test "x$with_window_manager" == "xmetacity"],
+      [WM_REQUIRES="libmetacity-private >= 2.23.1"
+       AC_DEFINE(HAVE_METACITY, 1, [defined if using metacity])],
+      [test "x$with_window_manager" == "xmutter"],
+      [WM_REQUIRES="libmutter-private >= 2.23.1"
+       AC_DEFINE(HAVE_MUTTER, 1, [defined if using mutter])],
+      [AC_MSG_FAILURE([Unsuported window manager: "$with_window_manager"])])
+
+PKG_CHECK_MODULES(WINDOW_MANAGER, $WM_REQUIRES)
+
+CAPPLET_LIBS="$CAPPLET_LIBS $WINDOW_MANAGER_LIBS"
+
 dnl End: Check that we meet the  dependencies
 dnl ==============================================
 
@@ -244,6 +283,17 @@ fi
 
 AC_SUBST(GLIB_GENMARSHAL)
 
+
+dnl ==============================================
+dnl Moblin specific tweaks
+dnl ==============================================
+AC_ARG_ENABLE(moblin, AC_HELP_STRING([--enable-moblin],[Build Moblin version]))
+if test x"$enable_moblin" = xyes; then
+  AC_DEFINE(HAVE_MOBLIN, 1, [Define if we are building for Moblin])
+fi
+
+AM_CONDITIONAL(HAVE_MOBLIN, test "x$enable_moblin" = "xyes")
+
 dnl ==============================================
 dnl Special GConf section
 dnl ==============================================
@@ -260,7 +310,7 @@ dnl ==============================================
 dnl Define the main variables
 dnl ==============================================
 COMMON_CFLAGS="-I\$(top_srcdir)/capplets/common"
-COMMON_LIBS="\$(top_builddir)/capplets/common/libcommon.la"
+COMMON_LIBS="\$(top_builddir)/capplets/common/libgnome-control-center-extension.la"
 
 EXTRA_CFLAGS="-I\$(top_srcdir)/ -DG_LOG_DOMAIN=\"\\\"\$(cappletname)-properties\\\"\""
 
@@ -302,6 +352,8 @@ capplets/appearance/data/Makefile
 capplets/appearance/data/gnome-appearance-properties.desktop.in
 capplets/appearance/data/gnome-theme-installer.desktop.in
 capplets/common/Makefile
+capplets/common/libgnome-control-center-extension.pc
+capplets/common/libgnome-control-center-extension-uninstalled.pc
 capplets/default-applications/Makefile
 capplets/default-applications/default-applications.desktop.in
 capplets/default-applications/gnome-at-commandline.in
diff --git a/po/POTFILES.in b/po/POTFILES.in
index ccf81df..aa0a9e4 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -78,6 +78,7 @@ shell/control-center.c
 shell/control-center.schemas.in
 shell/gnomecc.desktop.in.in
 shell/gnomecc.directory.in
+[type: gettext/glade]shell/shell.ui
 typing-break/drw-break-window.c
 typing-break/drwright.c
 typing-break/main.c
diff --git a/shell/Makefile.am b/shell/Makefile.am
index 915d75a..6b4831d 100644
--- a/shell/Makefile.am
+++ b/shell/Makefile.am
@@ -1,27 +1,57 @@
-if HAVE_LIBSLAB_DEPS
-REAL_LIBSLAB_CFLAGS = -I$(top_srcdir)/libslab
-REAL_LIBSLAB_LIBS = $(top_builddir)/libslab/libslab.la
-else
-REAL_LIBSLAB_CFLAGS = $(EXTERNAL_LIBSLAB_CFLAGS)
-REAL_LIBSLAB_LIBS = $(EXTERNAL_LIBSLAB_LIBS)
-endif
-
+NULL =
 INCLUDES =					\
 	-I$(top_srcdir)				\
-	$(REAL_LIBSLAB_CFLAGS)			\
-	$(GNOMECC_SHELL_CFLAGS)
+	$(EXTENSION_CFLAGS)			\
+	$(EXTENSION_COMMON_CFLAGS)		\
+	$(GNOMECC_SHELL_CFLAGS)			\
+	$(NULL)
+
+bin_PROGRAMS = gnome-control-center
+
+MARSHAL_FILES = cc-shell-marshal.c cc-shell-marshal.h
+BUILT_SOURCES = $(MARSHAL_FILES)
 
-bin_PROGRAMS = gnome-control-center 
+cc-shell-marshal.h: cc-shell-marshal.list
+	@GLIB_GENMARSHAL@ --prefix=cc_shell_marshal $< --header > $@
 
-gnome_control_center_SOURCES =		\
-	control-center.c
+cc-shell-marshal.c: cc-shell-marshal.list
+	@GLIB_GENMARSHAL@ --prefix=cc_shell_marshal $< --body --header > $@
 
-gnome_control_center_LDADD =						\
-	$(GNOMECC_SHELL_LIBS)						\
-	$(REAL_LIBSLAB_LIBS)
+gnome_control_center_SOURCES =			\
+	gnome-control-center.c			\
+	control-center.c			\
+	control-center.h			\
+	shell-search-renderer.c			\
+	shell-search-renderer.h			\
+	cc-shell-category-view.c		\
+	cc-shell-category-view.h		\
+	cc-shell-item-view.c			\
+	cc-shell-item-view.h			\
+	cc-shell-model.c			\
+	cc-shell-model.h			\
+	$(MARSHAL_FILES)			\
+	$(NULL)
+
+gnome_control_center_LDADD =			\
+	$(EXTENSION_LIBS)			\
+	$(EXTENSION_COMMON_LIBS)		\
+	$(GNOMECC_SHELL_LIBS)			\
+	$(NULL)
+
+gnome_control_center_LDFLAGS = -export-dynamic
 
 AM_CPPFLAGS =							\
-	-DGNOMELOCALEDIR="\"$(datadir)/locale\""
+	-DGNOMELOCALEDIR="\"$(datadir)/locale\""		\
+	-DEXTENSIONSDIR="\"$(EXTENSIONSDIR)\""			\
+	-DUIDIR="\"$(uidir)\""					\
+	-DMENUDIR="\"$(menudir)\""				\
+	$(NULL)
+
+menudir = $(sysconfdir)/xdg/menus
+menu_DATA = gnomecc.menu
+
+uidir = $(pkgdatadir)/ui
+ui_DATA = shell.ui
 
 sysdir = $(datadir)/applications
 sys_in_files = gnomecc.desktop.in
@@ -46,10 +76,14 @@ if GCONF_SCHEMAS_INSTALL
 	fi
 endif
 
-menudir = $(sysconfdir)/xdg/menus
-menu_DATA = gnomecc.menu
-
-EXTRA_DIST = gnomecc.desktop.in.in gnomecc.directory.in gnomecc.menu $(schemas_DATA).in
+EXTRA_DIST = 					\
+	$(ui_DATA)				\
+	gnomecc.directory.in			\
+	gnomecc.menu				\
+	cc-shell-marshal.list			\
+	$(schemas_DATA).in			\
+	cc-shell-marshal.list			\
+	$(NULL)
 
 DISTCLEANFILES = gnomecc.desktop gnomecc.desktop.in gnomecc.directory $(schemas_DATA)
 
diff --git a/shell/cc-shell-category-view.c b/shell/cc-shell-category-view.c
new file mode 100644
index 0000000..58ec775
--- /dev/null
+++ b/shell/cc-shell-category-view.c
@@ -0,0 +1,278 @@
+/*
+ * Copyright (c) 2010 Intel, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+#include <config.h>
+
+#include "cc-shell-category-view.h"
+#include "cc-shell-item-view.h"
+#include "cc-shell.h"
+#include "control-center.h"
+#include "cc-shell-model.h"
+
+G_DEFINE_TYPE (CcShellCategoryView, cc_shell_category_view, GTK_TYPE_FRAME)
+
+#define SHELL_CATEGORY_VIEW_PRIVATE(o) \
+  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_SHELL_CATEGORY_VIEW, CcShellCategoryViewPrivate))
+
+enum
+{
+  PROP_NAME = 1,
+  PROP_MODEL
+};
+
+struct _CcShellCategoryViewPrivate
+{
+  gchar *name;
+  GtkTreeModel *model;
+
+  GtkWidget *header;
+  GtkWidget *iconview;
+};
+
+static void
+cc_shell_category_view_get_property (GObject    *object,
+                                     guint       property_id,
+                                     GValue     *value,
+                                     GParamSpec *pspec)
+{
+  CcShellCategoryViewPrivate *priv = CC_SHELL_CATEGORY_VIEW (object)->priv;
+
+  switch (property_id)
+    {
+    case PROP_NAME:
+      g_value_set_string (value, priv->name);
+      break;
+
+    case PROP_MODEL:
+      g_value_set_object (value, priv->model);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
+}
+
+static void
+cc_shell_category_view_set_property (GObject      *object,
+                                     guint         property_id,
+                                     const GValue *value,
+                                     GParamSpec   *pspec)
+{
+  CcShellCategoryViewPrivate *priv = CC_SHELL_CATEGORY_VIEW (object)->priv;
+
+  switch (property_id)
+    {
+    case PROP_NAME:
+      priv->name = g_value_dup_string (value);
+      break;
+
+    case PROP_MODEL:
+      priv->model = g_value_dup_object (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
+}
+
+static void
+cc_shell_category_view_dispose (GObject *object)
+{
+  CcShellCategoryViewPrivate *priv = CC_SHELL_CATEGORY_VIEW (object)->priv;
+
+  if (priv->model)
+    {
+      g_object_unref (priv->model);
+      priv->model = NULL;
+    }
+
+  G_OBJECT_CLASS (cc_shell_category_view_parent_class)->dispose (object);
+}
+
+static void
+cc_shell_category_view_finalize (GObject *object)
+{
+  CcShellCategoryViewPrivate *priv = CC_SHELL_CATEGORY_VIEW (object)->priv;
+
+  if (priv->name)
+    {
+      g_free (priv->name);
+      priv->name = NULL;
+    }
+
+  G_OBJECT_CLASS (cc_shell_category_view_parent_class)->finalize (object);
+}
+
+static void
+cc_shell_category_view_constructed (GObject *object)
+{
+  CcShellCategoryViewPrivate *priv = CC_SHELL_CATEGORY_VIEW (object)->priv;
+  gchar *header_name;
+  GtkWidget *iconview, *vbox, *header, *self;
+
+  self = GTK_WIDGET (object);
+
+  iconview = cc_shell_item_view_new ();
+  gtk_icon_view_set_model (GTK_ICON_VIEW (iconview), priv->model);
+
+  vbox = gtk_vbox_new (FALSE, 0);
+
+  gtk_icon_view_set_pixbuf_column (GTK_ICON_VIEW (iconview), COL_PIXBUF);
+  gtk_icon_view_set_text_column (GTK_ICON_VIEW (iconview), COL_NAME);
+#if HAVE_MOBLIN
+    {
+      GList *renderers, *l;
+
+      gtk_icon_view_set_orientation (GTK_ICON_VIEW (iconview),
+                                     GTK_ORIENTATION_HORIZONTAL);
+      gtk_icon_view_set_item_width (GTK_ICON_VIEW (iconview), 200);
+      gtk_icon_view_set_spacing (GTK_ICON_VIEW (iconview), 6);
+
+      /* set cell renderer yalign */
+      renderers = gtk_cell_layout_get_cells (GTK_CELL_LAYOUT (iconview));
+      for (l = renderers; l; l = g_list_next (l))
+        {
+          g_object_set (l->data, "yalign", 0.0, "xalign", 0.0, "ypad", 0, NULL);
+        }
+      g_list_free (renderers);
+    }
+#else
+  gtk_icon_view_set_item_width (GTK_ICON_VIEW (iconview), 120);
+#endif
+
+  /* create the header if required */
+  if (priv->name)
+    {
+      header_name = g_strdup_printf ("<b>%s</b>", priv->name);
+
+      header = g_object_new (GTK_TYPE_LABEL,
+                             "use-markup", TRUE,
+                             "label", header_name,
+                             "wrap", TRUE,
+                             "xalign", 0.0,
+                             "xpad", 12,
+                             "ypad", 6,
+                             NULL);
+
+      g_free (header_name);
+      gtk_box_pack_start (GTK_BOX (vbox), header, FALSE, TRUE, 3);
+
+      priv->header = header;
+    }
+
+  /* add the iconview to the vbox */
+#if HAVE_MOBLIN
+  gtk_box_pack_start (GTK_BOX (vbox), iconview, TRUE, TRUE, 0);
+#else
+  gtk_box_pack_start (GTK_BOX (vbox), iconview, FALSE, TRUE, 0);
+#endif
+
+  /* add the main vbox to the view */
+  gtk_container_add (GTK_CONTAINER (object), vbox);
+  gtk_widget_show_all (vbox);
+
+  priv->iconview = iconview;
+}
+
+static void
+cc_shell_category_view_style_set (GtkWidget *widget,
+                                  GtkStyle  *old_style)
+{
+  CcShellCategoryViewPrivate *priv = CC_SHELL_CATEGORY_VIEW (widget)->priv;
+
+#ifndef HAVE_MOBLIN
+  if (priv->header)
+    {
+      gtk_widget_modify_bg (priv->header, GTK_STATE_NORMAL,
+                            &widget->style->base[GTK_STATE_NORMAL]);
+      gtk_widget_modify_fg (priv->header, GTK_STATE_NORMAL,
+                            &widget->style->text[GTK_STATE_NORMAL]);
+    }
+#endif
+
+  if (priv->iconview)
+    {
+      gtk_widget_modify_bg (priv->iconview, GTK_STATE_NORMAL,
+                            &widget->style->base[GTK_STATE_NORMAL]);
+      gtk_widget_modify_fg (priv->iconview, GTK_STATE_NORMAL,
+                            &widget->style->text[GTK_STATE_NORMAL]);
+    }
+}
+
+static void
+cc_shell_category_view_class_init (CcShellCategoryViewClass *klass)
+{
+  GParamSpec *pspec;
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (CcShellCategoryViewPrivate));
+
+  object_class->get_property = cc_shell_category_view_get_property;
+  object_class->set_property = cc_shell_category_view_set_property;
+  object_class->dispose = cc_shell_category_view_dispose;
+  object_class->finalize = cc_shell_category_view_finalize;
+  object_class->constructed = cc_shell_category_view_constructed;
+
+  widget_class->style_set = cc_shell_category_view_style_set;
+
+  pspec = g_param_spec_string ("name",
+                               "Name",
+                               "Name of the category",
+                               NULL,
+                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
+                               | G_PARAM_STATIC_STRINGS);
+  g_object_class_install_property (object_class, PROP_NAME, pspec);
+
+  pspec = g_param_spec_object ("model",
+                               "Model",
+                               "Model of the category",
+                               GTK_TYPE_TREE_MODEL,
+                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
+                               | G_PARAM_STATIC_STRINGS);
+  g_object_class_install_property (object_class, PROP_MODEL, pspec);
+
+}
+
+static void
+cc_shell_category_view_init (CcShellCategoryView *self)
+{
+  self->priv = SHELL_CATEGORY_VIEW_PRIVATE (self);
+
+#if HAVE_MOBLIN
+  gtk_frame_set_shadow_type (GTK_FRAME (self), GTK_SHADOW_IN);
+#else
+  gtk_frame_set_shadow_type (GTK_FRAME (self), GTK_SHADOW_NONE);
+#endif
+}
+
+GtkWidget *
+cc_shell_category_view_new (const gchar  *name,
+                            GtkTreeModel *model)
+{
+  return g_object_new (CC_TYPE_SHELL_CATEGORY_VIEW,
+                       "name", name,
+                       "model", model, NULL);
+}
+
+CcShellItemView*
+cc_shell_category_view_get_item_view (CcShellCategoryView *self)
+{
+  return (CcShellItemView*) self->priv->iconview;
+}
diff --git a/shell/cc-shell-category-view.h b/shell/cc-shell-category-view.h
new file mode 100644
index 0000000..d434501
--- /dev/null
+++ b/shell/cc-shell-category-view.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2010 Intel, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+
+#ifndef _CC_SHELL_CATEGORY_VIEW_H
+#define _CC_SHELL_CATEGORY_VIEW_H
+
+#include <gtk/gtk.h>
+#include "cc-shell-item-view.h"
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_SHELL_CATEGORY_VIEW cc_shell_category_view_get_type()
+
+#define CC_SHELL_CATEGORY_VIEW(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
+  CC_TYPE_SHELL_CATEGORY_VIEW, CcShellCategoryView))
+
+#define CC_SHELL_CATEGORY_VIEW_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST ((klass), \
+  CC_TYPE_SHELL_CATEGORY_VIEW, CcShellCategoryViewClass))
+
+#define CC_IS_SHELL_CATEGORY_VIEW(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
+  CC_TYPE_SHELL_CATEGORY_VIEW))
+
+#define CC_IS_SHELL_CATEGORY_VIEW_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
+  CC_TYPE_SHELL_CATEGORY_VIEW))
+
+#define CC_SHELL_CATEGORY_VIEW_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
+  CC_TYPE_SHELL_CATEGORY_VIEW, CcShellCategoryViewClass))
+
+typedef struct _CcShellCategoryView CcShellCategoryView;
+typedef struct _CcShellCategoryViewClass CcShellCategoryViewClass;
+typedef struct _CcShellCategoryViewPrivate CcShellCategoryViewPrivate;
+
+struct _CcShellCategoryView
+{
+  GtkFrame parent;
+
+  CcShellCategoryViewPrivate *priv;
+};
+
+struct _CcShellCategoryViewClass
+{
+  GtkFrameClass parent_class;
+};
+
+GType cc_shell_category_view_get_type (void) G_GNUC_CONST;
+
+GtkWidget *cc_shell_category_view_new (const gchar  *name,
+                                       GtkTreeModel *model);
+CcShellItemView* cc_shell_category_view_get_item_view (CcShellCategoryView *self);
+
+G_END_DECLS
+
+#endif /* _CC_SHELL_CATEGORY_VIEW_H */
diff --git a/shell/cc-shell-item-view.c b/shell/cc-shell-item-view.c
new file mode 100644
index 0000000..a1cd9d7
--- /dev/null
+++ b/shell/cc-shell-item-view.c
@@ -0,0 +1,194 @@
+/*
+ * Copyright (c) 2010 Intel, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+#include "cc-shell-item-view.h"
+#include "cc-shell-model.h"
+#include "cc-shell-marshal.h"
+
+G_DEFINE_TYPE (CcShellItemView, cc_shell_item_view, GTK_TYPE_ICON_VIEW)
+
+#define SHELL_ITEM_VIEW_PRIVATE(o) \
+  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CC_TYPE_SHELL_ITEM_VIEW, CcShellItemViewPrivate))
+
+struct _CcShellItemViewPrivate
+{
+  gboolean ignore_release;
+};
+
+
+enum
+{
+  DESKTOP_ITEM_ACTIVATED,
+
+  LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = {0,};
+
+static void
+cc_shell_item_view_get_property (GObject    *object,
+                                 guint       property_id,
+                                 GValue     *value,
+                                 GParamSpec *pspec)
+{
+  switch (property_id)
+    {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
+}
+
+static void
+cc_shell_item_view_set_property (GObject      *object,
+                                 guint         property_id,
+                                 const GValue *value,
+                                 GParamSpec   *pspec)
+{
+  switch (property_id)
+    {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
+}
+
+static void
+cc_shell_item_view_dispose (GObject *object)
+{
+  G_OBJECT_CLASS (cc_shell_item_view_parent_class)->dispose (object);
+}
+
+static void
+cc_shell_item_view_finalize (GObject *object)
+{
+  G_OBJECT_CLASS (cc_shell_item_view_parent_class)->finalize (object);
+}
+
+static gboolean
+iconview_button_press_event_cb (GtkWidget       *widget,
+                                GdkEventButton  *event,
+                                CcShellItemView *cc_view)
+{
+  /* be sure to ignore double and triple clicks */
+  cc_view->priv->ignore_release = (event->type != GDK_BUTTON_PRESS);
+
+  return FALSE;
+}
+
+static gboolean
+iconview_button_release_event_cb (GtkWidget       *widget,
+                                  GdkEventButton  *event,
+                                  CcShellItemView *cc_view)
+{
+  CcShellItemViewPrivate *priv = cc_view->priv;
+
+  if (event->button == 1 && !priv->ignore_release)
+    {
+      GList *selection;
+
+      selection =
+        gtk_icon_view_get_selected_items (GTK_ICON_VIEW (cc_view));
+
+      if (!selection)
+        return TRUE;
+
+      gtk_icon_view_item_activated (GTK_ICON_VIEW (cc_view),
+                                    (GtkTreePath*) selection->data);
+
+      g_list_free (selection);
+    }
+
+  return TRUE;
+}
+
+static void
+iconview_item_activated_cb (GtkIconView     *icon_view,
+                            GtkTreePath     *path,
+                            CcShellItemView *cc_view)
+{
+  GtkTreeModel *model;
+  GtkTreeIter iter;
+  gchar *name, *desktop_file, *id;
+
+  model = gtk_icon_view_get_model (icon_view);
+
+  gtk_icon_view_unselect_all (icon_view);
+
+  /* get the iter and ensure it is valid */
+  if (!gtk_tree_model_get_iter (model, &iter, path))
+    return;
+
+  gtk_tree_model_get (model, &iter,
+                      COL_NAME, &name,
+                      COL_DESKTOP_FILE, &desktop_file,
+                      COL_ID, &id,
+                      -1);
+
+  g_signal_emit (cc_view, signals[DESKTOP_ITEM_ACTIVATED], 0,
+                 name, id, desktop_file);
+
+  g_free (desktop_file);
+  g_free (name);
+  g_free (id);
+}
+
+static void
+cc_shell_item_view_class_init (CcShellItemViewClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (CcShellItemViewPrivate));
+
+  object_class->get_property = cc_shell_item_view_get_property;
+  object_class->set_property = cc_shell_item_view_set_property;
+  object_class->dispose = cc_shell_item_view_dispose;
+  object_class->finalize = cc_shell_item_view_finalize;
+
+  signals[DESKTOP_ITEM_ACTIVATED] = g_signal_new ("desktop-item-activated",
+                                                  CC_TYPE_SHELL_ITEM_VIEW,
+                                                  G_SIGNAL_RUN_FIRST,
+                                                  0,
+                                                  NULL,
+                                                  NULL,
+                                                  cc_shell_marshal_VOID__STRING_STRING_STRING,
+                                                  G_TYPE_NONE,
+                                                  3,
+                                                  G_TYPE_STRING,
+                                                  G_TYPE_STRING,
+                                                  G_TYPE_STRING);
+}
+
+static void
+cc_shell_item_view_init (CcShellItemView *self)
+{
+  self->priv = SHELL_ITEM_VIEW_PRIVATE (self);
+
+  g_signal_connect (self, "item-activated",
+                    G_CALLBACK (iconview_item_activated_cb), self);
+  g_signal_connect (self, "button-press-event",
+                    G_CALLBACK (iconview_button_press_event_cb), self);
+  g_signal_connect (self, "button-release-event",
+                    G_CALLBACK (iconview_button_release_event_cb), self);
+}
+
+GtkWidget *
+cc_shell_item_view_new (void)
+{
+  return g_object_new (CC_TYPE_SHELL_ITEM_VIEW, NULL);
+}
diff --git a/shell/cc-shell-item-view.h b/shell/cc-shell-item-view.h
new file mode 100644
index 0000000..ec27f14
--- /dev/null
+++ b/shell/cc-shell-item-view.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2010 Intel, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+#ifndef _CC_SHELL_ITEM_VIEW_H
+#define _CC_SHELL_ITEM_VIEW_H
+
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_SHELL_ITEM_VIEW cc_shell_item_view_get_type()
+
+#define CC_SHELL_ITEM_VIEW(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
+  CC_TYPE_SHELL_ITEM_VIEW, CcShellItemView))
+
+#define CC_SHELL_ITEM_VIEW_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST ((klass), \
+  CC_TYPE_SHELL_ITEM_VIEW, CcShellItemViewClass))
+
+#define CC_IS_SHELL_ITEM_VIEW(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
+  CC_TYPE_SHELL_ITEM_VIEW))
+
+#define CC_IS_SHELL_ITEM_VIEW_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
+  CC_TYPE_SHELL_ITEM_VIEW))
+
+#define CC_SHELL_ITEM_VIEW_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
+  CC_TYPE_SHELL_ITEM_VIEW, CcShellItemViewClass))
+
+typedef struct _CcShellItemView CcShellItemView;
+typedef struct _CcShellItemViewClass CcShellItemViewClass;
+typedef struct _CcShellItemViewPrivate CcShellItemViewPrivate;
+
+struct _CcShellItemView
+{
+  GtkIconView parent;
+
+  CcShellItemViewPrivate *priv;
+};
+
+struct _CcShellItemViewClass
+{
+  GtkIconViewClass parent_class;
+};
+
+GType cc_shell_item_view_get_type (void) G_GNUC_CONST;
+
+GtkWidget *cc_shell_item_view_new (void);
+
+G_END_DECLS
+
+#endif /* _CC_SHELL_ITEM_VIEW_H */
diff --git a/shell/cc-shell-marshal.list b/shell/cc-shell-marshal.list
new file mode 100644
index 0000000..41e4027
--- /dev/null
+++ b/shell/cc-shell-marshal.list
@@ -0,0 +1 @@
+VOID:STRING,STRING,STRING
diff --git a/shell/cc-shell-model.c b/shell/cc-shell-model.c
new file mode 100644
index 0000000..3bd4d31
--- /dev/null
+++ b/shell/cc-shell-model.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2009, 2010 Intel, Inc.
+ * Copyright (c) 2010 Red Hat, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+#include "cc-shell-model.h"
+#include <string.h>
+
+G_DEFINE_TYPE (CcShellModel, cc_shell_model, GTK_TYPE_LIST_STORE)
+
+static void
+cc_shell_model_class_init (CcShellModelClass *klass)
+{
+
+}
+
+static void
+cc_shell_model_init (CcShellModel *self)
+{
+  GType types[] = {G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING,
+      GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING};
+
+  gtk_list_store_set_column_types (GTK_LIST_STORE (self),
+                                   N_COLS, types);
+}
+
+CcShellModel *
+cc_shell_model_new (void)
+{
+  return g_object_new (CC_TYPE_SHELL_MODEL, NULL);
+}
+
+void
+cc_shell_model_add_item (CcShellModel   *model,
+                         const gchar    *category_name,
+                         GMenuTreeEntry *item)
+{
+  const gchar *icon = gmenu_tree_entry_get_icon (item);
+  const gchar *name = gmenu_tree_entry_get_name (item);
+  const gchar *id = gmenu_tree_entry_get_desktop_file_id (item);
+  const gchar *desktop = gmenu_tree_entry_get_desktop_file_path (item);
+  const gchar *comment = gmenu_tree_entry_get_comment (item);
+  GdkPixbuf *pixbuf = NULL;
+  gchar *icon2 = NULL;
+  GError *err = NULL;
+  gchar *search_target;
+
+  if (icon != NULL && *icon == '/')
+    {
+      pixbuf = gdk_pixbuf_new_from_file_at_scale (icon, 32, 32, TRUE, &err);
+    }
+  else
+    {
+      if (icon2 == NULL && icon != NULL && g_str_has_suffix (icon, ".png"))
+        icon2 = g_strndup (icon, strlen (icon) - strlen (".png"));
+
+      pixbuf = gtk_icon_theme_load_icon (gtk_icon_theme_get_default (),
+                                         icon2 ? icon2 : icon, 32,
+                                         GTK_ICON_LOOKUP_FORCE_SIZE,
+                                         &err);
+    }
+
+  if (err)
+    {
+      g_warning ("Could not load icon '%s': %s", icon2 ? icon2 : icon,
+                 err->message);
+      g_error_free (err);
+    }
+
+  g_free (icon2);
+
+  search_target = g_strconcat (name, " - ", comment, NULL);
+
+  gtk_list_store_insert_with_values (GTK_LIST_STORE (model), NULL, 0,
+                                     COL_NAME, name,
+                                     COL_DESKTOP_FILE, desktop,
+                                     COL_ID, id,
+                                     COL_PIXBUF, pixbuf,
+                                     COL_CATEGORY, category_name,
+                                     COL_SEARCH_TARGET, search_target,
+                                     -1);
+
+  g_free (search_target);
+
+}
diff --git a/shell/cc-shell-model.h b/shell/cc-shell-model.h
new file mode 100644
index 0000000..851b7d2
--- /dev/null
+++ b/shell/cc-shell-model.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2010 Intel, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+
+#ifndef _CC_SHELL_MODEL_H
+#define _CC_SHELL_MODEL_H
+
+#include <gtk/gtk.h>
+#define GMENU_I_KNOW_THIS_IS_UNSTABLE
+#include <gmenu-tree.h>
+
+G_BEGIN_DECLS
+
+#define CC_TYPE_SHELL_MODEL cc_shell_model_get_type()
+
+#define CC_SHELL_MODEL(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
+  CC_TYPE_SHELL_MODEL, CcShellModel))
+
+#define CC_SHELL_MODEL_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST ((klass), \
+  CC_TYPE_SHELL_MODEL, CcShellModelClass))
+
+#define CC_IS_SHELL_MODEL(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
+  CC_TYPE_SHELL_MODEL))
+
+#define CC_IS_SHELL_MODEL_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
+  CC_TYPE_SHELL_MODEL))
+
+#define CC_SHELL_MODEL_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
+  CC_TYPE_SHELL_MODEL, CcShellModelClass))
+
+typedef struct _CcShellModel CcShellModel;
+typedef struct _CcShellModelClass CcShellModelClass;
+
+enum
+{
+  COL_NAME,
+  COL_DESKTOP_FILE,
+  COL_ID,
+  COL_PIXBUF,
+  COL_CATEGORY,
+  COL_SEARCH_TARGET,
+
+  N_COLS
+};
+
+struct _CcShellModel
+{
+  GtkListStore parent;
+};
+
+struct _CcShellModelClass
+{
+  GtkListStoreClass parent_class;
+};
+
+GType cc_shell_model_get_type (void) G_GNUC_CONST;
+
+CcShellModel *cc_shell_model_new (void);
+
+void cc_shell_model_add_item (CcShellModel   *model,
+                              const gchar    *category_name,
+                              GMenuTreeEntry *item);
+
+G_END_DECLS
+
+#endif /* _CC_SHELL_MODEL_H */
diff --git a/shell/control-center.c b/shell/control-center.c
index c4c154d..b49a2c3 100644
--- a/shell/control-center.c
+++ b/shell/control-center.c
@@ -1,197 +1,713 @@
 /*
- * This file is part of the Control Center.
+ * Copyright (c) 2010 Intel, Inc.
+ * Copyright (c) 2010 Red Hat, Inc.
  *
- * Copyright (c) 2006 Novell, Inc.
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * The Control Center is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
  *
- * The Control Center is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
- * You should have received a copy of the GNU General Public License along with
- * the Control Center; if not, write to the Free Software Foundation, Inc., 51
- * Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ * Author: Thomas Wood <thos@gnome.org>
  */
 
 #include "config.h"
 
+#include "control-center.h"
+
 #include <glib/gi18n.h>
+#include <gio/gio.h>
+#include <gio/gdesktopappinfo.h>
 #include <gtk/gtk.h>
-#include <libgnome/gnome-desktop-item.h>
-#include <unique/unique.h>
-
-#include <libslab/slab.h>
-
-void handle_static_action_clicked (Tile * tile, TileEvent * event, gpointer data);
-static GSList *get_actions_list ();
-
-#define CONTROL_CENTER_PREFIX             "/apps/control-center/cc_"
-#define CONTROL_CENTER_ACTIONS_LIST_KEY   (CONTROL_CENTER_PREFIX  "actions_list")
-#define CONTROL_CENTER_ACTIONS_SEPARATOR  ";"
-#define EXIT_SHELL_ON_STATIC_ACTION       "exit_shell_on_static_action"
-
-static GSList *
-get_actions_list (void)
-{
-	GSList *l;
-	GSList *key_list;
-	GSList *actions_list = NULL;
-	AppAction *action;
-
-	key_list = get_slab_gconf_slist (CONTROL_CENTER_ACTIONS_LIST_KEY);
-	if (!key_list)
-	{
-		g_warning (_("key not found [%s]\n"), CONTROL_CENTER_ACTIONS_LIST_KEY);
-		return NULL;
-	}
-
-	for (l = key_list; l != NULL; l = l->next)
-	{
-		gchar *entry = (gchar *) l->data;
-		gchar **temp;
-
-		action = g_new (AppAction, 1);
-		temp = g_strsplit (entry, CONTROL_CENTER_ACTIONS_SEPARATOR, 2);
-		action->name = g_strdup (temp[0]);
-		if ((action->item = load_desktop_item_from_unknown (temp[1])) == NULL)
-		{
-			g_warning ("get_actions_list() - PROBLEM - Can't load %s\n", temp[1]);
-		}
-		else
-		{
-			actions_list = g_slist_prepend (actions_list, action);
-		}
-		g_strfreev (temp);
-		g_free (entry);
-	}
-
-	g_slist_free (key_list);
-
-	return g_slist_reverse (actions_list);
+#include <gdk/gdkkeysyms.h>
+#include <string.h>
+#define GMENU_I_KNOW_THIS_IS_UNSTABLE
+#include <gmenu-tree.h>
+
+#include "cc-panel.h"
+#include "shell-search-renderer.h"
+#include "cc-shell-category-view.h"
+#include "cc-shell-model.h"
+
+G_DEFINE_TYPE (ControlCenter, control_center, CC_TYPE_SHELL)
+
+#define SHELL_PRIVATE(o) \
+  (G_TYPE_INSTANCE_GET_PRIVATE ((o), CONTROL_TYPE_CENTER, ControlCenterPrivate))
+
+struct _ControlCenterPrivate
+{
+  CcPanel *current_panel;
+  GHashTable *panels;
+  GtkBuilder *builder;
+
+
+
+  GtkWidget  *notebook;
+  GtkWidget  *window;
+  GtkWidget  *search_entry;
+
+  GtkListStore *store;
+
+  GtkTreeModel *search_filter;
+  GtkWidget *search_view;
+  GtkCellRenderer *search_renderer;
+  gchar *filter_string;
+
+  gboolean ignore_release;
+  guint last_time;
+};
+
+#define W(b,x) GTK_WIDGET (gtk_builder_get_object (b, x))
+
+static void
+control_center_dispose (GObject *object)
+{
+  G_OBJECT_CLASS (control_center_parent_class)->dispose (object);
+}
+
+static void
+control_center_finalize (GObject *object)
+{
+  ControlCenterPrivate *priv = ((ControlCenter*) (object))->priv;
+
+  if (priv->panels)
+    {
+      g_hash_table_destroy (priv->panels);
+      priv->panels = NULL;
+    }
+
+  G_OBJECT_CLASS (control_center_parent_class)->finalize (object);
+}
+
+static gboolean
+control_center_set_panel (CcShell     *shell,
+                          const gchar *id)
+{
+  CcPanel *panel;
+  ControlCenterPrivate *priv = CONTROL_CENTER (shell)->priv;
+  GtkWidget *notebook;
+  GtkWidget *title_label, *title_alignment;
+  gchar *desktop_file, *name;
+  GtkTreeIter iter;
+  gboolean iter_valid;
+
+  notebook = W (priv->builder, "notebook");
+
+
+  if (priv->current_panel != NULL)
+    cc_panel_set_active (priv->current_panel, FALSE);
+
+
+  /* clear the search text */
+  g_free (priv->filter_string);
+  priv->filter_string = g_strdup ("");
+  gtk_entry_set_text (GTK_ENTRY (priv->search_entry), "");
+
+
+  title_label = W (priv->builder, "label-title");
+  title_alignment = W (priv->builder, "title-alignment");
+
+
+  /* if there is a current panel, remove it from the parent manually to
+   * avoid it being destroyed */
+  if (priv->current_panel)
+    {
+      GtkContainer *container;
+      GtkWidget *widget;
+
+      widget = GTK_WIDGET (priv->current_panel);
+      container = (GtkContainer *) gtk_widget_get_parent (widget);
+      gtk_container_remove (container, widget);
+
+      priv->current_panel = NULL;
+      gtk_notebook_remove_page (GTK_NOTEBOOK (notebook), CAPPLET_PAGE);
+    }
+
+  /* if no id, show the overview page */
+  if (id == NULL || !strcmp (id, ""))
+    {
+      gtk_label_set_text (GTK_LABEL (title_label), "");
+      gtk_widget_hide (title_alignment);
+
+      gtk_notebook_set_current_page (GTK_NOTEBOOK (notebook),
+                                     OVERVIEW_PAGE);
+      return TRUE;
+    }
+
+  /* find the information for this id  */
+  iter_valid = gtk_tree_model_get_iter_first (GTK_TREE_MODEL (priv->store),
+                                              &iter);
+  while (iter_valid)
+    {
+      gchar *s;
+
+      /* find the details for this item */
+      gtk_tree_model_get (GTK_TREE_MODEL (priv->store), &iter,
+                          COL_ID, &s, COL_DESKTOP_FILE, &desktop_file,
+                          COL_NAME, &name, -1);
+      if (s && !strcmp (id, s))
+        {
+          g_free (s);
+          break;
+        }
+      else
+        {
+          g_free (s);
+          g_free (desktop_file);
+          g_free (name);
+
+          name = NULL;
+          s = NULL;
+          desktop_file = NULL;
+        }
+
+      iter_valid = gtk_tree_model_iter_next (GTK_TREE_MODEL (priv->store),
+                                             &iter);
+    }
+
+  /* first look for a panel module */
+  panel = g_hash_table_lookup (priv->panels, id);
+  if (panel != NULL)
+    {
+      GtkWidget *scroll, *view;
+
+      priv->current_panel = panel;
+      gtk_container_set_border_width (GTK_CONTAINER (panel), 12);
+      gtk_widget_show_all (GTK_WIDGET (panel));
+      cc_panel_set_active (panel, TRUE);
+
+      scroll = gtk_scrolled_window_new (NULL, NULL);
+      gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scroll),
+                                      GTK_POLICY_AUTOMATIC,
+                                      GTK_POLICY_AUTOMATIC);
+      view = gtk_viewport_new (NULL, NULL);
+      gtk_viewport_set_shadow_type (GTK_VIEWPORT (view), GTK_SHADOW_NONE);
+      gtk_container_add (GTK_CONTAINER (view), GTK_WIDGET (panel));
+
+      gtk_container_add (GTK_CONTAINER (scroll), view);
+      gtk_widget_show_all (scroll);
+
+      gtk_notebook_insert_page (GTK_NOTEBOOK (notebook),
+                                GTK_WIDGET (scroll), NULL, CAPPLET_PAGE);
+
+      gtk_notebook_set_current_page (GTK_NOTEBOOK (notebook),
+                                     CAPPLET_PAGE);
+
+      /* show title */
+      gtk_label_set_text (GTK_LABEL (title_label), name);
+      gtk_widget_show (title_label);
+      gtk_widget_show (title_alignment);
+
+      g_free (name);
+      g_free (desktop_file);
+
+      return TRUE;
+    }
+  else
+    {
+      GAppInfo *appinfo;
+      GError *err = NULL;
+      GdkAppLaunchContext *ctx;
+      GKeyFile *key_file;
+
+      /* start app directly */
+      g_debug ("Panel module not found for %s", id);
+
+      /* remove the title and show the overview page */
+      gtk_label_set_text (GTK_LABEL (title_label), "");
+      gtk_widget_hide (title_alignment);
+      gtk_notebook_set_current_page (GTK_NOTEBOOK (notebook), OVERVIEW_PAGE);
+
+      if (!desktop_file)
+        return FALSE;
+
+      key_file = g_key_file_new ();
+      g_key_file_load_from_file (key_file, desktop_file, 0, &err);
+
+      g_free (name);
+      g_free (desktop_file);
+
+      if (err)
+        {
+          g_warning ("Error starting \"%s\": %s", id, err->message);
+
+          g_error_free (err);
+          err = NULL;
+          return FALSE;
+        }
+
+      appinfo = (GAppInfo*) g_desktop_app_info_new_from_keyfile (key_file);
+
+      g_key_file_free (key_file);
+
+
+      ctx = gdk_app_launch_context_new ();
+      gdk_app_launch_context_set_screen (ctx, gdk_screen_get_default ());
+      gdk_app_launch_context_set_timestamp (ctx, priv->last_time);
+
+      g_app_info_launch (appinfo, NULL, G_APP_LAUNCH_CONTEXT (ctx), &err);
+
+      g_object_unref (appinfo);
+      g_object_unref (ctx);
+
+      if (err)
+        {
+          g_warning ("Error starting \"%s\": %s", id, err->message);
+          g_error_free (err);
+          err = NULL;
+        }
+      return FALSE;
+    }
+}
+
+static void
+control_center_class_init (ControlCenterClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  CcShellClass *shell_class = CC_SHELL_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (ControlCenterPrivate));
+
+  object_class->dispose = control_center_dispose;
+  object_class->finalize = control_center_finalize;
+
+  shell_class->set_panel = control_center_set_panel;
+}
+
+
+static void
+load_panel_plugins (ControlCenter *shell)
+{
+  ControlCenterPrivate *priv = shell->priv;
+  static volatile GType panel_type = G_TYPE_INVALID;
+  static GIOExtensionPoint *ep = NULL;
+  GList *modules;
+  GList *panel_implementations;
+  GList *l;
+
+  /* make sure base type is registered */
+  if (panel_type == G_TYPE_INVALID)
+    {
+      panel_type = g_type_from_name ("CcPanel");
+    }
+
+  priv->panels = g_hash_table_new_full (g_str_hash, g_str_equal, g_free,
+                                        g_object_unref);
+
+  if (ep == NULL)
+    {
+      ep = g_io_extension_point_register (CC_PANEL_EXTENSION_POINT_NAME);
+    }
+
+  /* load all modules */
+  modules = g_io_modules_load_all_in_directory (EXTENSIONSDIR);
+
+  /* find all extensions */
+  panel_implementations = g_io_extension_point_get_extensions (ep);
+  for (l = panel_implementations; l != NULL; l = l->next)
+    {
+      GIOExtension *extension;
+      CcPanel *panel;
+      char *id;
+
+      extension = l->data;
+
+      panel = g_object_new (g_io_extension_get_type (extension),
+                            "shell", shell,
+                            NULL);
+
+      /* take ownership of the object to prevent it being destroyed */
+      g_object_ref_sink (panel);
+
+      g_object_get (panel, "id", &id, NULL);
+      g_hash_table_insert (priv->panels, g_strdup (id), g_object_ref (panel));
+      g_free (id);
+    }
+
+  /* unload all modules; the module our instantiated authority is in won't be
+   * unloaded because we've instantiated a reference to a type in this module
+   */
+  g_list_foreach (modules, (GFunc) g_type_module_unuse, NULL);
+  g_list_free (modules);
+}
+
+
+static void
+item_activated_cb (CcShellCategoryView *view,
+                   gchar               *name,
+                   gchar               *id,
+                   gchar               *desktop_file,
+                   CcShell             *shell)
+{
+  cc_shell_set_panel (shell, id);
+}
+
+
+static void
+search_entry_changed_cb (GtkEntry      *entry,
+                         ControlCenter *shell)
+{
+  ControlCenterPrivate *priv = shell->priv;
+
+  /* if the entry text was set manually (not by the user) */
+  if (!g_strcmp0 (priv->filter_string, gtk_entry_get_text (entry)))
+    return;
+
+  g_free (priv->filter_string);
+  priv->filter_string = g_strdup (gtk_entry_get_text (entry));
+
+  g_object_set (priv->search_renderer,
+                "search-string", priv->filter_string,
+                NULL);
+
+  if (!g_strcmp0 (priv->filter_string, ""))
+    {
+      cc_shell_set_panel (CC_SHELL (shell), NULL);
+    }
+  else
+    {
+      gtk_tree_model_filter_refilter (GTK_TREE_MODEL_FILTER (priv->search_filter));
+      gtk_notebook_set_current_page (GTK_NOTEBOOK (priv->notebook), SEARCH_PAGE);
+
+      gtk_label_set_text (GTK_LABEL (gtk_builder_get_object (priv->builder, "label-title")), "");
+      gtk_widget_hide (GTK_WIDGET (gtk_builder_get_object (priv->builder, "title-alignment")));
+    }
+}
+
+static gboolean
+search_entry_key_press_event_cb (GtkEntry      *entry,
+                                 GdkEventKey   *event,
+                                 ControlCenter *shell)
+{
+  ControlCenterPrivate *priv = shell->priv;
+
+  priv->last_time = event->time;
+
+  if (event->keyval == GDK_Return)
+    {
+      GtkTreePath *path;
+
+      path = gtk_tree_path_new_first ();
+
+      gtk_icon_view_item_activated (GTK_ICON_VIEW (priv->search_view), path);
+
+      gtk_tree_path_free (path);
+      return TRUE;
+    }
+
+  if (event->keyval == GDK_Escape)
+    {
+      gtk_entry_set_text (entry, "");
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+static void
+search_entry_clear_cb (GtkEntry *entry)
+{
+  gtk_entry_set_text (entry, "");
+}
+
+
+static gboolean
+model_filter_func (GtkTreeModel  *model,
+                   GtkTreeIter   *iter,
+                   ControlCenter *shell)
+{
+  ControlCenterPrivate *priv = shell->priv;
+  gchar *name, *target;
+  gchar *needle, *haystack;
+  gboolean result;
+
+  gtk_tree_model_get (model, iter, COL_NAME, &name,
+                      COL_SEARCH_TARGET, &target, -1);
+
+  if (!priv->filter_string || !name || !target)
+    {
+      g_free (name);
+      g_free (target);
+      return FALSE;
+    }
+
+  needle = g_utf8_casefold (priv->filter_string, -1);
+  haystack = g_utf8_casefold (target, -1);
+
+  result = (strstr (haystack, needle) != NULL);
+
+  g_free (name);
+  g_free (target);
+  g_free (haystack);
+  g_free (needle);
+
+  return result;
+}
+
+static gboolean
+category_filter_func (GtkTreeModel *model,
+                      GtkTreeIter  *iter,
+                      gchar        *filter)
+{
+  gchar *category;
+  gboolean result;
+
+  gtk_tree_model_get (model, iter, COL_CATEGORY, &category, -1);
+
+  result = (g_strcmp0 (category, filter) == 0);
+
+  g_free (category);
+
+  return result;
+}
+
+static void
+setup_search (ControlCenter *shell)
+{
+  GtkWidget *search_scrolled, *search_view, *widget;
+  ControlCenterPrivate *priv = shell->priv;
+
+  g_return_if_fail (priv->store != NULL);
+
+  /* create the search filter */
+  priv->search_filter = gtk_tree_model_filter_new (GTK_TREE_MODEL (priv->store),
+                                                   NULL);
+
+  gtk_tree_model_filter_set_visible_func (GTK_TREE_MODEL_FILTER (priv->search_filter),
+                                          (GtkTreeModelFilterVisibleFunc)
+                                            model_filter_func,
+                                          shell, NULL);
+
+  /* set up the search view */
+  priv->search_view = search_view = cc_shell_item_view_new ();
+  gtk_icon_view_set_orientation (GTK_ICON_VIEW (search_view),
+                                 GTK_ORIENTATION_HORIZONTAL);
+  gtk_icon_view_set_spacing (GTK_ICON_VIEW (search_view), 6);
+  gtk_icon_view_set_model (GTK_ICON_VIEW (search_view),
+                           GTK_TREE_MODEL (priv->search_filter));
+  gtk_icon_view_set_pixbuf_column (GTK_ICON_VIEW (search_view), COL_PIXBUF);
+
+  search_scrolled = W (priv->builder, "search-scrolled-window");
+  gtk_container_add (GTK_CONTAINER (search_scrolled), search_view);
+
+
+  /* add the custom renderer */
+  priv->search_renderer = (GtkCellRenderer*) shell_search_renderer_new ();
+  gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (search_view),
+                              priv->search_renderer, TRUE);
+  gtk_cell_layout_add_attribute (GTK_CELL_LAYOUT (search_view),
+                                 priv->search_renderer,
+                                 "title", COL_NAME);
+  gtk_cell_layout_add_attribute (GTK_CELL_LAYOUT (search_view),
+                                 priv->search_renderer,
+                                 "search-target", COL_SEARCH_TARGET);
+
+  /* connect the activated signal */
+  g_signal_connect (search_view, "desktop-item-activated",
+                    G_CALLBACK (item_activated_cb), shell);
+
+
+  widget = (GtkWidget*) gtk_builder_get_object (priv->builder, "search-entry");
+  priv->search_entry = widget;
+
+  g_signal_connect (widget, "changed", G_CALLBACK (search_entry_changed_cb),
+                    shell);
+  g_signal_connect (widget, "key-press-event",
+                    G_CALLBACK (search_entry_key_press_event_cb), shell);
+  g_signal_connect (widget, "icon-release", G_CALLBACK (search_entry_clear_cb),
+                    NULL);
+
+}
+
+static void
+fill_model (ControlCenter *shell)
+{
+  ControlCenterPrivate *priv = shell->priv;
+  GSList *list, *l;
+  GMenuTreeDirectory *d;
+  GMenuTree *tree;
+  GtkWidget *vbox;
+
+  vbox = W (priv->builder, "main-vbox");
+  gtk_widget_set_size_request (vbox, 0, -1);
+
+  gtk_orientable_set_orientation (GTK_ORIENTABLE (vbox),
+                                  GTK_ORIENTATION_HORIZONTAL);
+  gtk_container_set_border_width (GTK_CONTAINER (vbox), 12);
+
+  tree = gmenu_tree_lookup (MENUDIR "/gnomecc.menu", 0);
+
+  if (!tree)
+    {
+      g_warning ("Could not find control center menu");
+      return;
+    }
+
+  d = gmenu_tree_get_root_directory (tree);
+
+  list = gmenu_tree_directory_get_contents (d);
+
+  priv->store = (GtkListStore *) cc_shell_model_new ();
+
+  for (l = list; l; l = l->next)
+    {
+      GMenuTreeItemType type;
+      type = gmenu_tree_item_get_type (l->data);
+
+      if (type == GMENU_TREE_ITEM_DIRECTORY)
+        {
+          GtkTreeModel *filter;
+          GtkWidget *categoryview;
+          GSList *contents, *f;
+          const gchar *dir_name;
+
+          contents = gmenu_tree_directory_get_contents (l->data);
+          dir_name = gmenu_tree_directory_get_name (l->data);
+
+          /* create new category view for this category */
+          filter = gtk_tree_model_filter_new (GTK_TREE_MODEL (priv->store),
+                                              NULL);
+          gtk_tree_model_filter_set_visible_func (GTK_TREE_MODEL_FILTER (filter),
+                                                  (GtkTreeModelFilterVisibleFunc) category_filter_func,
+                                                  g_strdup (dir_name), g_free);
+
+          categoryview = cc_shell_category_view_new (dir_name, filter);
+          gtk_box_pack_start (GTK_BOX (vbox), categoryview, TRUE, TRUE, 6);
+          g_signal_connect (cc_shell_category_view_get_item_view (CC_SHELL_CATEGORY_VIEW (categoryview)),
+                            "desktop-item-activated",
+                            G_CALLBACK (item_activated_cb), shell);
+          gtk_widget_show (categoryview);
+
+          /* add the items from this category to the model */
+          for (f = contents; f; f = f->next)
+            {
+              if (gmenu_tree_item_get_type (f->data) == GMENU_TREE_ITEM_ENTRY)
+                {
+                  cc_shell_model_add_item (CC_SHELL_MODEL (priv->store),
+                                           dir_name,
+                                           f->data);
+                }
+            }
+        }
+    }
+
+}
+
+static void
+home_button_clicked_cb (GtkButton     *button,
+                        ControlCenter *shell)
+{
+  cc_shell_set_panel (CC_SHELL (shell), NULL);
+}
+
+static void
+notebook_switch_page_cb (GtkNotebook     *book,
+                         GtkNotebookPage *page,
+                         gint             page_num,
+                         ControlCenter   *shell)
+{
+  ControlCenterPrivate *priv = shell->priv;
+
+  /* make sure the home button is shown on all pages except the overview page */
+
+  if (page_num == OVERVIEW_PAGE)
+    gtk_widget_hide (W (priv->builder, "home-button"));
+  else
+    gtk_widget_show (W (priv->builder, "home-button"));
+
+  if (page_num == CAPPLET_PAGE)
+    gtk_widget_hide (W (priv->builder, "search-entry"));
+  else
+    gtk_widget_show (W (priv->builder, "search-entry"));
+}
+
+
+
+static void
+control_center_init (ControlCenter *self)
+{
+  ControlCenterPrivate *priv;
+  GError *err = NULL;
+  GtkWidget *close_button;
+
+  priv = self->priv = SHELL_PRIVATE (self);
+
+
+  /* load UI */
+  priv->builder = gtk_builder_new ();
+  gtk_builder_add_from_file (priv->builder, UIDIR "/shell.ui", &err);
+
+  if (err)
+    {
+      g_warning ("Could not load UI file: %s", err->message);
+
+      g_error_free (err);
+
+      g_object_unref (priv->builder);
+      priv->builder = NULL;
+
+      return;
+    }
+
+
+  priv->window = W (priv->builder, "main-window");
+  g_signal_connect (priv->window, "delete-event", G_CALLBACK (gtk_main_quit),
+                    NULL);
+
+  priv->notebook = W (priv->builder, "notebook");
+
+  g_signal_connect (priv->notebook, "switch-page",
+                    G_CALLBACK (notebook_switch_page_cb), self);
+
+  fill_model (self);
+
+  g_signal_connect (gtk_builder_get_object (priv->builder, "home-button"),
+                    "clicked", G_CALLBACK (home_button_clicked_cb), self);
+
+  setup_search (self);
+
+  /* meego stuff */
+  close_button = gtk_button_new ();
+  gtk_widget_set_name (close_button, "moblin-close-button");
+  gtk_container_add (GTK_CONTAINER (close_button),
+                     gtk_image_new_from_icon_name ("window-close",
+                                                   GTK_ICON_SIZE_LARGE_TOOLBAR));
+  gtk_widget_set_name (GTK_WIDGET (gtk_builder_get_object (priv->builder,
+                                                           "toolbar1")),
+                       "moblin-toolbar");
+  gtk_box_pack_end (GTK_BOX (gtk_builder_get_object (priv->builder, "hbox1")),
+                    close_button, FALSE, TRUE, 6);
+
+  g_signal_connect (close_button, "clicked", G_CALLBACK (gtk_main_quit),
+                    NULL);
+
+  gtk_window_maximize (GTK_WINDOW (priv->window));
+  gtk_window_set_decorated (GTK_WINDOW (priv->window), FALSE);
+
+  /* load settings panels */
+  load_panel_plugins (self);
+
+  gtk_widget_show_all (priv->window);
+}
+
+
+CcShell *
+control_center_new ()
+{
+  return g_object_new (CONTROL_TYPE_CENTER, NULL);
 }
 
 void
-handle_static_action_clicked (Tile * tile, TileEvent * event, gpointer data)
-{
-	gchar *temp;
-	AppShellData *app_data = (AppShellData *) data;
-	GnomeDesktopItem *item =
-		(GnomeDesktopItem *) g_object_get_data (G_OBJECT (tile), APP_ACTION_KEY);
-
-	if (event->type == TILE_EVENT_ACTIVATED_DOUBLE_CLICK)
-		return;
-	open_desktop_item_exec (item);
-
-	temp = g_strdup_printf("%s%s", app_data->gconf_prefix, EXIT_SHELL_ON_STATIC_ACTION);
-	if (get_slab_gconf_bool(temp))
-	{
-		if (app_data->exit_on_close)
-			gtk_main_quit ();
-		else
-			hide_shell (app_data);
-	}
-	g_free (temp);
-}
-
-static UniqueResponse
-message_received_cb (UniqueApp         *app,
-		     UniqueCommand      command,
-		     UniqueMessageData *message,
-		     guint              time,
-		     gpointer           user_data)
-{
-	UniqueResponse  res;
-	AppShellData   *app_data = user_data;
-
-	switch (command) {
-	case UNIQUE_ACTIVATE:
-		/* move the main window to the screen that sent us the command */
-		gtk_window_set_screen (GTK_WINDOW (app_data->main_app),
-				       unique_message_data_get_screen (message));
-		if (!app_data->main_app_window_shown_once)
-			show_shell (app_data);
-
-		gtk_window_present_with_time (GTK_WINDOW (app_data->main_app),
-					      time);
-
-		gtk_widget_grab_focus (SLAB_SECTION (app_data->filter_section)->contents);
-
-		res = UNIQUE_RESPONSE_OK;
-		break;
-	default:
-		res = UNIQUE_RESPONSE_PASSTHROUGH;
-		break;
-	}
-
-	return res;
-}
-
-int
-main (int argc, char *argv[])
-{
-	gboolean hidden = FALSE;
-	UniqueApp *unique_app;
-	AppShellData *app_data;
-	GSList *actions;
-	GError *error;
-	GOptionEntry options[] = {
-	  { "hide", 0, 0, G_OPTION_ARG_NONE, &hidden, N_("Hide on start (useful to preload the shell)"), NULL },
-	  { NULL }
-	};
-
-#ifdef ENABLE_NLS
-	bindtextdomain (GETTEXT_PACKAGE, GNOMELOCALEDIR);
-	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-	textdomain (GETTEXT_PACKAGE);
-#endif
-
-	error = NULL;
-	if (!gtk_init_with_args (&argc, &argv,
-				 NULL, options, GETTEXT_PACKAGE, &error)) {
-		g_printerr ("%s\n", error->message);
-		g_error_free (error);
-		return 1;
-	}
-
-	unique_app = unique_app_new ("org.opensuse.yast-control-center-gnome", NULL);
-	if (unique_app_is_running (unique_app)) {
-		int retval = 0;
-
-		if (!hidden) {
-			UniqueResponse response;
-			response = unique_app_send_message (unique_app,
-							    UNIQUE_ACTIVATE,
-							    NULL);
-			retval = (response != UNIQUE_RESPONSE_OK);
-		}
-
-		g_object_unref (unique_app);
-		return retval;
-	}
-
-	app_data = appshelldata_new ("gnomecc.menu", NULL, CONTROL_CENTER_PREFIX,
-				     GTK_ICON_SIZE_DND, FALSE, TRUE);
-	generate_categories (app_data);
-
-	actions = get_actions_list ();
-	layout_shell (app_data, _("Filter"), _("Groups"), _("Common Tasks"), actions,
-		handle_static_action_clicked);
-
-	create_main_window (app_data, "MyControlCenter", _("Control Center"),
-		"gnome-control-center", 975, 600, hidden);
-
-	unique_app_watch_window (unique_app, GTK_WINDOW (app_data->main_app));
-	g_signal_connect (unique_app, "message-received",
-			  G_CALLBACK (message_received_cb), app_data);
-
-	gtk_main ();
-
-	g_object_unref (unique_app);
-
-	return 0;
-};
+control_center_present (ControlCenter *shell)
+{
+  gtk_window_present (GTK_WINDOW (shell->priv->window));
+}
+
diff --git a/shell/control-center.h b/shell/control-center.h
new file mode 100644
index 0000000..f909b9d
--- /dev/null
+++ b/shell/control-center.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2010 Intel, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+#ifndef _CONTROL_CENTER_H
+#define _CONTROL_CENTER_H
+
+#include <gtk/gtk.h>
+
+#include "cc-shell.h"
+
+G_BEGIN_DECLS
+
+#define CONTROL_TYPE_CENTER control_center_get_type()
+
+#define CONTROL_CENTER(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
+  CONTROL_TYPE_CENTER, ControlCenter))
+
+#define CONTROL_CENTER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST ((klass), \
+  CONTROL_TYPE_CENTER, ControlCenterClass))
+
+#define CONTROL_IS_CENTER(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
+  CONTROL_TYPE_CENTER))
+
+#define CONTROL_IS_CENTER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
+  CONTROL_TYPE_CENTER))
+
+#define CONTROL_CENTER_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
+  CONTROL_TYPE_CENTER, ControlCenterClass))
+
+enum
+{
+  OVERVIEW_PAGE,
+  SEARCH_PAGE,
+  CAPPLET_PAGE
+};
+
+typedef struct _ControlCenter ControlCenter;
+typedef struct _ControlCenterClass ControlCenterClass;
+typedef struct _ControlCenterPrivate ControlCenterPrivate;
+
+struct _ControlCenter
+{
+  CcShell  parent;
+
+  ControlCenterPrivate *priv;
+};
+
+struct _ControlCenterClass
+{
+  CcShellClass parent_class;
+};
+
+GType control_center_get_type (void) G_GNUC_CONST;
+
+CcShell *control_center_new (void);
+void control_center_present (ControlCenter *shell);
+
+G_END_DECLS
+
+#endif /* _CONTROL_CENTER_H */
diff --git a/shell/gnome-control-center.c b/shell/gnome-control-center.c
new file mode 100644
index 0000000..0986597
--- /dev/null
+++ b/shell/gnome-control-center.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2009, 2010 Intel, Inc.
+ * Copyright (c) 2010 Red Hat, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+#include "config.h"
+
+#include "control-center.h"
+
+#include <unique/unique.h>
+#include <glib/gi18n.h>
+
+#define CC_SHELL_RAISE_COMMAND 1
+
+static UniqueResponse
+message_received (UniqueApp         *app,
+                  gint               command,
+                  UniqueMessageData *message_data,
+                  guint              time_,
+                  CcShell           *shell)
+{
+  const gchar *id;
+  gsize len;
+
+  control_center_present (CONTROL_CENTER (shell));
+
+  id = (gchar*) unique_message_data_get (message_data, &len);
+
+  if (id)
+    {
+      cc_shell_set_panel (shell, id);
+    }
+
+  return GTK_RESPONSE_OK;
+}
+
+int
+main (int argc, char **argv)
+{
+  UniqueApp *unique;
+  CcShell *shell;
+
+  bindtextdomain (GETTEXT_PACKAGE, GNOMELOCALEDIR);
+  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+  textdomain (GETTEXT_PACKAGE);
+
+  g_thread_init (NULL);
+  gtk_init (&argc, &argv);
+
+  unique = unique_app_new_with_commands ("org.gnome.ControlCenter",
+                                         NULL,
+                                         "raise",
+                                         CC_SHELL_RAISE_COMMAND,
+                                         NULL);
+
+  if (unique_app_is_running (unique))
+    {
+      UniqueMessageData *data;
+      if (argc == 2)
+        {
+          data = unique_message_data_new ();
+          unique_message_data_set (data, (guchar*) argv[1],
+                                   strlen(argv[1]) + 1);
+        }
+      else
+        data = NULL;
+
+      unique_app_send_message (unique, 1, data);
+
+      gdk_notify_startup_complete ();
+      return 0;
+    }
+
+  shell = control_center_new ();
+
+  g_signal_connect (unique, "message-received", G_CALLBACK (message_received),
+                    shell);
+
+
+  if (argc == 2)
+    {
+      gchar *start_id;
+
+      start_id = argv[1];
+
+      cc_shell_set_panel (shell, start_id);
+    }
+
+  gtk_main ();
+
+  return 0;
+}
diff --git a/shell/shell-search-renderer.c b/shell/shell-search-renderer.c
new file mode 100644
index 0000000..08cada5
--- /dev/null
+++ b/shell/shell-search-renderer.c
@@ -0,0 +1,299 @@
+/*
+ * Copyright (c) 2010 Intel, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+#include "shell-search-renderer.h"
+#include <string.h>
+
+G_DEFINE_TYPE (ShellSearchRenderer, shell_search_renderer, GTK_TYPE_CELL_RENDERER)
+
+#define SEARCH_RENDERER_PRIVATE(o) \
+  (G_TYPE_INSTANCE_GET_PRIVATE ((o), SHELL_TYPE_SEARCH_RENDERER, ShellSearchRendererPrivate))
+
+struct _ShellSearchRendererPrivate
+{
+  gchar *title;
+  gchar *search_target;
+  gchar *search_string;
+
+  PangoLayout *layout;
+};
+
+enum
+{
+  PROP_TITLE = 1,
+  PROP_SEARCH_TARGET,
+  PROP_SEARCH_STRING
+};
+
+
+static void
+shell_search_renderer_get_property (GObject    *object,
+                                    guint       property_id,
+                                    GValue     *value,
+                                    GParamSpec *pspec)
+{
+  switch (property_id)
+    {
+  case PROP_TITLE:
+  case PROP_SEARCH_TARGET:
+  case PROP_SEARCH_STRING:
+    break;
+
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
+}
+
+static void
+shell_search_renderer_set_property (GObject      *object,
+                                    guint         property_id,
+                                    const GValue *value,
+                                    GParamSpec   *pspec)
+{
+  ShellSearchRendererPrivate *priv = SHELL_SEARCH_RENDERER (object)->priv;
+
+  switch (property_id)
+    {
+  case PROP_TITLE:
+    g_free (priv->title);
+    priv->title = g_value_dup_string (value);
+    break;
+
+  case PROP_SEARCH_TARGET:
+    g_free (priv->search_target);
+    priv->search_target = g_value_dup_string (value);
+    break;
+
+  case PROP_SEARCH_STRING:
+    g_free (priv->search_string);
+    priv->search_string = g_value_dup_string (value);
+    break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+    }
+}
+
+static void
+shell_search_renderer_dispose (GObject *object)
+{
+  ShellSearchRendererPrivate *priv = SHELL_SEARCH_RENDERER (object)->priv;
+
+  if (priv->layout)
+    {
+      g_object_unref (priv->layout);
+      priv->layout = NULL;
+    }
+
+  G_OBJECT_CLASS (shell_search_renderer_parent_class)->dispose (object);
+}
+
+static void
+shell_search_renderer_finalize (GObject *object)
+{
+  ShellSearchRendererPrivate *priv = SHELL_SEARCH_RENDERER (object)->priv;
+
+  if (priv->title)
+    {
+      g_free (priv->title);
+      priv->title = NULL;
+    }
+
+  if (priv->search_target)
+    {
+      g_free (priv->search_target);
+      priv->search_target = NULL;
+    }
+
+  if (priv->search_string)
+    {
+      g_free (priv->search_string);
+      priv->search_string = NULL;
+    }
+
+  G_OBJECT_CLASS (shell_search_renderer_parent_class)->finalize (object);
+}
+
+static void
+shell_search_renderer_set_layout (ShellSearchRenderer *cell, GtkWidget *widget)
+{
+  gchar *display_string;
+  ShellSearchRendererPrivate *priv = cell->priv;
+  gchar *needle, *haystack;
+  gchar *full_string;
+
+  if (!priv->layout)
+    {
+      priv->layout = pango_layout_new (gtk_widget_get_pango_context (widget));
+      pango_layout_set_ellipsize (priv->layout, PANGO_ELLIPSIZE_END);
+    }
+
+  full_string = priv->search_target;
+
+  needle = g_utf8_casefold (priv->search_string, -1);
+  haystack = g_utf8_casefold (full_string, -1);
+
+  /* clear any previous attributes */
+  pango_layout_set_attributes (priv->layout, NULL);
+
+  if (priv->search_string && priv->title
+      && (strstr (haystack, needle)))
+    {
+      gchar *start;
+      gchar *lead, *trail, *leaddot;
+      gint count;
+#define CONTEXT 10
+
+      count = strlen (needle);
+      start = strstr (haystack, needle);
+
+      lead = MAX (start - CONTEXT, haystack);
+      trail = start + count;
+
+      if (lead == haystack)
+        leaddot = "";
+      else
+        leaddot = "...";
+
+      lead = g_strndup (lead, start - lead);
+
+      display_string = g_markup_printf_escaped ("%s\n"
+                                                "<small>%s%s<b>%s</b>%s</small>",
+                                                priv->title, leaddot, lead,
+                                                needle, trail);
+
+      g_free (lead);
+    }
+  else
+    display_string = g_markup_escape_text (priv->title, -1);
+
+
+  pango_layout_set_markup (priv->layout, display_string, -1);
+  g_free (display_string);
+  g_free (needle);
+  g_free (haystack);
+}
+
+static void
+shell_search_renderer_get_size (GtkCellRenderer    *cell,
+                                GtkWidget          *widget,
+                                GdkRectangle       *cell_area,
+                                gint               *x_offset,
+                                gint               *y_offset,
+                                gint               *width,
+                                gint               *height)
+{
+  ShellSearchRendererPrivate *priv = SHELL_SEARCH_RENDERER (cell)->priv;
+  PangoRectangle rect;
+
+  shell_search_renderer_set_layout (SHELL_SEARCH_RENDERER (cell), widget);
+
+  pango_layout_set_width (priv->layout, PANGO_SCALE * 180);
+  pango_layout_get_pixel_extents (priv->layout, NULL, &rect);
+
+  if (width) *width = rect.width;
+  if (height) *height = rect.height;
+
+  if (x_offset) *x_offset = 0;
+  if (y_offset) *y_offset = 0;
+
+}
+
+static void
+shell_search_renderer_render (GtkCellRenderer      *cell,
+                              GdkDrawable          *window,
+                              GtkWidget            *widget,
+                              GdkRectangle         *background_area,
+                              GdkRectangle         *cell_area,
+                              GdkRectangle         *expose_area,
+                              GtkCellRendererState  flags)
+{
+  ShellSearchRendererPrivate *priv = SHELL_SEARCH_RENDERER (cell)->priv;
+  cairo_t *cr;
+  PangoRectangle rect;
+
+  shell_search_renderer_set_layout (SHELL_SEARCH_RENDERER (cell), widget);
+
+  cr = gdk_cairo_create (window);
+
+  pango_layout_get_pixel_extents (priv->layout, NULL, &rect);
+
+  cairo_move_to (cr, cell_area->x, cell_area->y);
+
+  /* FIXME: get the correct colour from the theme */
+  cairo_set_source_rgb (cr, 0, 0, 0);
+  if (priv->layout)
+    pango_cairo_layout_path (cr, priv->layout);
+  cairo_fill (cr);
+
+  cairo_destroy (cr);
+}
+
+static void
+shell_search_renderer_class_init (ShellSearchRendererClass *klass)
+{
+  GParamSpec *pspec;
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  GtkCellRendererClass *cell_renderer = GTK_CELL_RENDERER_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (ShellSearchRendererPrivate));
+
+  object_class->get_property = shell_search_renderer_get_property;
+  object_class->set_property = shell_search_renderer_set_property;
+  object_class->dispose = shell_search_renderer_dispose;
+  object_class->finalize = shell_search_renderer_finalize;
+
+  cell_renderer->get_size = shell_search_renderer_get_size;
+  cell_renderer->render = shell_search_renderer_render;
+
+  pspec = g_param_spec_string ("title",
+                               "Title",
+                               "Item title",
+                               "",
+                               G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+  g_object_class_install_property (object_class, PROP_TITLE, pspec);
+
+  pspec = g_param_spec_string ("search-target",
+                               "Search Target",
+                               "The string that will be searched",
+                               "",
+                               G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+  g_object_class_install_property (object_class, PROP_SEARCH_TARGET, pspec);
+
+  pspec = g_param_spec_string ("search-string",
+                               "Search String",
+                               "Current search string",
+                               "",
+                               G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+  g_object_class_install_property (object_class, PROP_SEARCH_STRING, pspec);
+}
+
+static void
+shell_search_renderer_init (ShellSearchRenderer *self)
+{
+  self->priv = SEARCH_RENDERER_PRIVATE (self);
+}
+
+ShellSearchRenderer *
+shell_search_renderer_new (void)
+{
+  return g_object_new (SHELL_TYPE_SEARCH_RENDERER, NULL);
+}
diff --git a/shell/shell-search-renderer.h b/shell/shell-search-renderer.h
new file mode 100644
index 0000000..d0dfd82
--- /dev/null
+++ b/shell/shell-search-renderer.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2010 Intel, Inc.
+ *
+ * The Control Center is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * The Control Center is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with the Control Center; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Thomas Wood <thos@gnome.org>
+ */
+
+#ifndef _SHELL_SEARCH_RENDERER_H
+#define _SHELL_SEARCH_RENDERER_H
+
+#include <glib-object.h>
+
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+#define SHELL_TYPE_SEARCH_RENDERER shell_search_renderer_get_type()
+
+#define SHELL_SEARCH_RENDERER(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
+  SHELL_TYPE_SEARCH_RENDERER, ShellSearchRenderer))
+
+#define SHELL_SEARCH_RENDERER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST ((klass), \
+  SHELL_TYPE_SEARCH_RENDERER, ShellSearchRendererClass))
+
+#define SHELL_IS_SEARCH_RENDERER(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
+  SHELL_TYPE_SEARCH_RENDERER))
+
+#define SHELL_IS_SEARCH_RENDERER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
+  SHELL_TYPE_SEARCH_RENDERER))
+
+#define SHELL_SEARCH_RENDERER_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
+  SHELL_TYPE_SEARCH_RENDERER, ShellSearchRendererClass))
+
+typedef struct _ShellSearchRenderer ShellSearchRenderer;
+typedef struct _ShellSearchRendererClass ShellSearchRendererClass;
+typedef struct _ShellSearchRendererPrivate ShellSearchRendererPrivate;
+
+struct _ShellSearchRenderer
+{
+  GtkCellRenderer parent;
+
+  ShellSearchRendererPrivate *priv;
+};
+
+struct _ShellSearchRendererClass
+{
+  GtkCellRendererClass parent_class;
+};
+
+GType shell_search_renderer_get_type (void) G_GNUC_CONST;
+
+ShellSearchRenderer *shell_search_renderer_new (void);
+
+G_END_DECLS
+
+#endif /* _SHELL_SEARCH_RENDERER_H */
diff --git a/shell/shell.ui b/shell/shell.ui
new file mode 100644
index 0000000..b19d22c
--- /dev/null
+++ b/shell/shell.ui
@@ -0,0 +1,169 @@
+<?xml version="1.0"?>
+<interface>
+  <requires lib="gtk+" version="2.16"/>
+  <!-- interface-naming-policy project-wide -->
+  <object class="GtkWindow" id="main-window">
+    <property name="title" translatable="yes">Settings</property>
+    <property name="default_width">800</property>
+    <property name="default_height">500</property>
+    <property name="icon_name">gnome-control-center</property>
+    <child>
+      <object class="GtkVBox" id="vbox1">
+        <property name="visible">True</property>
+        <property name="orientation">vertical</property>
+        <child>
+          <object class="GtkToolbar" id="toolbar1">
+            <property name="visible">True</property>
+            <child>
+              <object class="GtkToolItem" id="toolbutton1">
+                <property name="visible">True</property>
+                <child>
+                  <object class="GtkHBox" id="hbox1">
+                    <property name="visible">True</property>
+                    <property name="border_width">5</property>
+                    <child>
+                      <object class="GtkButton" id="home-button">
+                        <property name="label" translatable="yes">_All Settings</property>
+                        <property name="can_focus">True</property>
+                        <property name="receives_default">True</property>
+                        <property name="no_show_all">True</property>
+                        <property name="use_underline">True</property>
+                      </object>
+                      <packing>
+                        <property name="expand">False</property>
+                        <property name="position">0</property>
+                      </packing>
+                    </child>
+                    <child>
+                      <object class="GtkAlignment" id="entry-alignment">
+                        <property name="visible">True</property>
+                        <property name="xalign">1</property>
+                        <property name="xscale">0</property>
+                        <child>
+                          <object class="GtkEntry" id="search-entry">
+                            <property name="width_request">210</property>
+                            <property name="visible">True</property>
+                            <property name="can_focus">True</property>
+                            <property name="invisible_char">&#x25CF;</property>
+                            <property name="primary_icon_stock">gtk-find</property>
+                            <property name="secondary_icon_stock">gtk-clear</property>
+                            <property name="secondary_icon_activatable">True</property>
+                            <property name="secondary_icon_sensitive">True</property>
+                          </object>
+                        </child>
+                      </object>
+                      <packing>
+                        <property name="position">1</property>
+                      </packing>
+                    </child>
+                  </object>
+                </child>
+              </object>
+              <packing>
+                <property name="expand">True</property>
+                <property name="homogeneous">True</property>
+              </packing>
+            </child>
+          </object>
+          <packing>
+            <property name="expand">False</property>
+            <property name="position">0</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkAlignment" id="title-alignment">
+            <property name="no_show_all">True</property>
+            <property name="top_padding">12</property>
+            <property name="left_padding">12</property>
+            <child>
+              <object class="GtkLabel" id="label-title">
+                <property name="visible">True</property>
+                <property name="xalign">0</property>
+                <property name="yalign">0</property>
+                <attributes>
+                  <attribute name="weight" value="bold"/>
+                </attributes>
+              </object>
+            </child>
+          </object>
+          <packing>
+            <property name="expand">False</property>
+            <property name="position">1</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkNotebook" id="notebook">
+            <property name="visible">True</property>
+            <property name="can_focus">True</property>
+            <property name="show_tabs">False</property>
+            <property name="show_border">False</property>
+            <child>
+              <object class="GtkScrolledWindow" id="scrolledwindow1">
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="hscrollbar_policy">never</property>
+                <property name="vscrollbar_policy">automatic</property>
+                <child>
+                  <object class="GtkViewport" id="viewport1">
+                    <property name="visible">True</property>
+                    <property name="resize_mode">queue</property>
+                    <child>
+                      <object class="GtkVBox" id="main-vbox">
+                        <property name="visible">True</property>
+                        <property name="orientation">vertical</property>
+                        <child>
+                          <placeholder/>
+                        </child>
+                      </object>
+                    </child>
+                  </object>
+                </child>
+              </object>
+            </child>
+            <child type="tab">
+              <placeholder/>
+            </child>
+            <child>
+              <object class="GtkScrolledWindow" id="search-scrolled-window">
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="hscrollbar_policy">automatic</property>
+                <property name="vscrollbar_policy">automatic</property>
+                <property name="shadow_type">in</property>
+                <child>
+                  <placeholder/>
+                </child>
+              </object>
+              <packing>
+                <property name="position">1</property>
+              </packing>
+            </child>
+            <child type="tab">
+              <placeholder/>
+            </child>
+          </object>
+          <packing>
+            <property name="position">2</property>
+          </packing>
+        </child>
+      </object>
+    </child>
+  </object>
+  <object class="GtkListStore" id="liststore">
+    <columns>
+      <!-- column-name name -->
+      <column type="gchararray"/>
+      <!-- column-name exec -->
+      <column type="gchararray"/>
+      <!-- column-name icon -->
+      <column type="gchararray"/>
+    </columns>
+  </object>
+  <object class="GtkSizeGroup" id="sizegroup">
+    <property name="mode">vertical</property>
+    <widgets>
+      <widget name="home-button"/>
+      <widget name="entry-alignment"/>
+    </widgets>
+  </object>
+</interface>
-- 
1.7.2.3

